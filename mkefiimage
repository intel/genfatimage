#!/usr/bin/perl
# <add SPDX header here>
# Copyright 2025 Intel Corporation

use strict;
use integer;
use v5.16;
use utf8;
no indirect;

use Crypt::Random::Source;
use Digest::CRC qw(crc32);
use Encode;
use Fcntl qw(:DEFAULT :mode);
use File::Spec;
use File::Temp qw(tempfile);
use IO::Handle;
use IPC::Open3;

die "$0 a 64-bit integer Perl interpreter is required\n" unless (1 << 63);

# Options structure
my %opt = ();

# Constants for partition type; the ordering matters for command-line parsing.
# parsing
my $FLAT    = 1;
my $ANYPART = 2;
my $MBR     = 3;
my $GPT     = 4;

# The FAT and GPT Unicode encoding (UTF-16LE)
my $FATUNI = Encode::find_encoding('UTF-16LE');
# Convert a string to the "Unicode" as used by FAT and EFI
sub to_uni($) {
    my($s) = @_;
    return Encode::encode($FATUNI, $s, Encode::LEAVE_SRC);
}

sub min(@) {
    my $x;
    foreach my $y (@_) {
	next unless (defined($y));
	$x = $y if (!defined($x) || $y < $x);
    }
    return $x;
}
sub max(@) {
    my $x;
    foreach my $y (@_) {
	next unless (defined($y));
	$x = $y if (!defined($x) || $y > $x);
    }
    return $x;
}

sub align_down($$) {
    my($val, $align) = @_;
    return $val - ($val % $align);
}
sub align_up($$) {
    my($val, $align) = @_;
    return align_down($val + $align - 1, $align);
}
sub div_up($$) {
    my($val, $divisor) = @_;
    return ($val + $divisor - 1)/$divisor;
}

# Code to kill a BIOS boot: 1: int $0x80; hlt; jmp 1b
my $KILLBOOT = "\xcd\x18\xf4\xeb\xfb";

# Create a random (type 4) GUID
# For Crypt::Random::Source < 0.13 using get_strong() would be better
sub rand_bytes($) {
    my($count) = @_;

    if (Crypt::Random::Source->VERSION < 0.13) {
	return Crypt::Random::Source::get_strong($count);
    } else {
	return Crypt::Random::Source::get_weak($count);
    }
}

# Yeah, the byte ordering here is weird as heck
sub guid($$$$$) {
    my($a,$b,$c,$d,$e) = @_;
    return pack('VvvQ>', $a, $b, $c, ($d << 48) | $e);
}

sub rand_guid() {
    my @b = unpack('C*', rand_bytes(16));
    $b[7] = ($b[7] & 0x0f) | 0x40; # Version 4 (random)
    $b[8] = ($b[8] & 0x3f) | 0x80; # Variant 1
    return pack('C*', @b);
}

sub to_chs($;$) {
    my($lba, $hs) = @_;
    $hs = [255, 63] unless (defined($hs));
    my $s = ($lba % $hs->[1]) + 1;
    my $t = $lba / $hs->[1];
    my $h = $t % $hs->[0];
    my $c = $t / $hs->[0];
    ($c,$h,$s) = (1023,$hs->[0]-1,$hs->[1]) if ($c > 1023);
    return pack('C3', $h, ($c >> 2)|$s, $c & 0xff);
}
# Create a minimal MBR partition table with one single partition.
sub gen_mbr($$$;$$)
{
    my($part_start, $part_len, $part_type, $hs, $active) = @_;
    my $part_end = min($part_start+$part_len-1, 0xffffffff);
    my $pe;
    if ($part_start <= 0xffffffff) {
	$pe = pack('Ca3Ca3VV',
		   $active ? 0x80 : 0, to_chs($part_start, $hs),
		   $part_type, to_chs($part_end, $hs), $part_start, $part_len);
    }
    return pack('a440a4va64v', $KILLBOOT, rand_bytes(4), 0, $pe, 0xaa55);
}

# Create a minimal GPT partition table with one single partition.
# Return a vector containing the PMBR, the GPT header,
# the GPT array, and the backup GPT header in that order.
# $gpt_len is the desired size of the GPT array in sectors.
sub gen_gpt($$$$$;$$) {
    my($disk_len, $part_start, $part_len, $part_type,
       $gpt_len, $part_name, $hs) = @_;
    my @blks;

    # PMBR
    $blks[0] = gen_mbr(1, $disk_len-1, 0xee, $hs);

    # GPT partition array
    $blks[2] = $part_type . rand_guid() .
	pack('Q<Q<Q<a142v', $part_start, $part_start + $part_len - 1, 1,
	     to_uni($part_name), 0);
    $blks[2] .= "\0" x (($gpt_len << 9) - length($blks[2]));
    my $array_crc = crc32($blks[2]);

    # GPT headers (primary and alternate)
    my $disk_guid = rand_guid();
    foreach my $hdr ([1, 1, $disk_len-1, 2],
		     [3, $disk_len-1, 1, $disk_len-$gpt_len-1]) {
	my($i, $here, $there, $array) = @$hdr;
	$blks[$i] = 'EFI PART'.
	    pack('VVVVQ<Q<Q<Q<', 0x10000, 92, 0, 0,
		 $here, $there, $gpt_len+2,  $disk_len-$gpt_len-2) .
	    $disk_guid .
	    pack('Q<VVV', $array, $gpt_len << 2, 128, $array_crc);

	my $hdr_crc = crc32($blks[$i]);
	substr($blks[$i], 16, 4) = pack('V', $hdr_crc);
	$blks[$i] .= ("\0" x (512 - length($blks[$i])));
    }

    return @blks;
}

# Create a normalization of a pathname as a list suitable for
# inserting in the directory tree.
sub pathlist($;$) {
    my($path, $from_host) = @_;
    my @rawpath;
    my($curdir, $updir);

    if ($from_host) {
	my @sp   = File::Spec->splitpath($path);
	my $cp   = File::Spec->catpath(undef, $sp[1], $sp[2]);
	@rawpath = File::Spec->splitdir($cp);
	$curdir  = File::Spec->curdir();
	$updir   = File::Spec->updir();
    } else {
	@rawpath = split(/[\/\\]+/, $path);
	$curdir  = '.';
	$updir   = '..';
    }

    my @path;
    foreach my $rp (@rawpath) {
	my $vn = $rp;
	if ($rp eq '' || $rp eq $curdir) {
	    next;
	} elsif ($rp eq $updir) {
	    pop(@path);
	} else {
	    push(@path, $rp);
	}
    }

    if (!scalar(@path)) {
	die "$0: empty path?: \"$path\"";
    }

    return @path;
}

# Error counter
my $err = 0;

# Directory entry types, and lists of nodes of each type
# Important: $VOL < $DIR < $FILE
my $VOL  = 0x08;
my $DIR  = 0x10;
my $FILE = 0x20;		# == ARCHIVE bit

# Normalize a filename coming from host space stripping things
# unsuitable for the FAT longname and forcing Perl to convert
# a string to characters rather than bytes
sub normalize_filename($) {
    my($vn) = @_;
    # Normalize name; this affects the retained name
    $vn = decode_utf8($vn);	# Convert to characters
    $vn =~ s/^\./_/;
    $vn =~ s/[\s\.]$/_/;
    $vn =~ tr/\"\*\/:<>?\\|/\'+;()!!/;
    return $vn;
}

sub set_node_type($$) {
    my($node, $type) = @_;
    die if ($node->{type});
    $node->{type} = $type;
    push(@{$node->{root}->{nodes}->{$type}}, $node);
}

# Creates or finds a node in the directory tree from a list of names
# and returns a reference to it
sub mktreenode($@) {
    my($here, @path) = @_;

    foreach my $p (@path) {
	my $herepath = $here->{path};

	if (!$here->{type}) {
	    set_node_type($here, $DIR);
	    $here->{files} = {};
	} elsif ($here->{type} != $DIR) {
	    print STDERR "$opt{outfile}: file and directory conflict: $herepath\n";
	    $err++;
	    return undef;
	}

	my $f = normalize_filename($p);
	my $uf = uc($f);
	my $there = $here;
	$here = $there->{files}->{$uf};
	if (!defined($here)) {
	    # New directory entry, unknown type so far
	    $here = {
		'root' => $there->{root}, 'up' => $there, 'name' => $f,
		'path' => $herepath.'/'.$f
	    };
	    $there->{files}->{$uf} = $here;
	}
    }

    return $here;
}

sub inputnode($$) {
    my($root, $inpath) = @_;

    my $dest;
    my @dest;
    if ($inpath =~ /^(.*)::(.*)$/) {
	$inpath = $1;
	$dest   = $2;
    }

    my @st = stat($inpath);
    if (!scalar(@st)) {
	print STDERR "$inpath: path not found\n";
	$err++;
	return;
    }

    if (!defined($dest)) {
	@dest = ();
    } elsif ($dest eq '') {
	@dest = pathlist($inpath, 1);
    } else {
	@dest = pathlist($dest, 0);
    }

    $dest = mktreenode($root, @dest);
    $dest->{inpath} = $inpath if (defined($dest));

    return $dest;
}

# Create the root directory node
sub rootdir() {
    my $root = {
	'path' => undef, 'name' => undef, 'date' => time(), 'files' => {},
	'type' => $DIR
    };
    $root->{root} = $root;
    $root->{nodes} = { $FILE => [], $VOL => [], $DIR => [$root] };
    return $root;
}

# Append a name to a directory path in host space
sub cat_path($$) {
    my($dir, $file) = @_;

    my @sp = File::Spec->splitpath($dir);
    $sp[1] = ($sp[1] eq '' || $sp[1] eq File::Spec->curdir)
	? $sp[2] : File::Spec->catdir($sp[1], $sp[2]);
    $sp[2] = $file;
    return File::Spec->catpath(@sp);
}

# Add an input file or directory to a directory node
sub add_input($;$) {
    my($dest, $inpath) = @_;
    return undef unless (defined($dest));

    $inpath = $dest->{inpath} unless (defined($inpath));

    my @st = stat($inpath);

    if (!scalar(@st)) {
	print STDERR "$opt{outfile}: input not found: $inpath\n";
	return;
    }
    my $mode = $st[2];

    $dest->{date}  = $st[9] if ($st[9] > $dest->{date});

    if (S_ISDIR($mode)) {
	if (!$dest->{type}) {
	    $dest->{files} = {};
	    $dest->{inpath} = $inpath;
	    set_node_type($dest, $DIR);
	} elsif ($dest->{type} != $DIR) {
	    printf STDERR "%s: file and directory conflict: %s (%s and %s)\n",
		$opt{outfile}, $dest->{path}, $dest->{inpath}, $inpath;
	    $err++;
	    return;
	}
	my $dh;
	if (!opendir($dh, $inpath)) {
	    printf STDERR "%s: cannot scan input directory: %s: %s\n",
		$opt{outfile}, $inpath, $!;
	    $err++;
	    return;
	}
	while (defined(my $de = readdir($dh))) {
	    next if ($de eq File::Spec->curdir() || $de eq File::Spec->updir());
	    my $node = mktreenode($dest, $de);
	    add_input($node, cat_path($inpath, $de));
	}
	closedir($dh);
    } elsif (S_ISREG($mode)) {
	if ($dest->{type}) {
	    printf STDERR "%s: file%s conflict: %s (%s and %s)\n",
		$opt{outfile}, $dest->{type} eq $DIR ? ' and directory' : '',
		$dest->{path}, $dest->{inpath}, $inpath;
	    $err++;
	    return;
	}
	set_node_type($dest, $FILE);
	$dest->{size}   = $st[7];
	$dest->{inpath} = $inpath;
	$dest->{flags}  = !($mode & S_IWRITE); # Readonly bit
    } else {
	printf STDERR "$opt{outfile}: skipping non-regular file: $inpath\n";
	$err++;
	return;
    }
}

#
# Read all the input files
#
sub read_inputs(@) {
    my(@inputs) = @_;

    my $root = rootdir();
    foreach my $input (@inputs) {
	add_input(inputnode($root, $input));
    }

    return $root;
}

# Convert a longname to UTF-16LE and pad it
sub genlongname($) {
    my($s) = @_;

    my $u = substr(to_uni($s), 0, 255 << 1);
    my $p = (length($u) >> 1) % 13;

    if ($p) {
	$u .= "\0\0";
	$u .= "\xff\xff" x (12-$p);
    }
    return $u;
}

# Generate a short filename. For simplicity, only consider
# non-whitespace ASCII characters as valid shortname characters, even
# though that is needlessly strict. This also avoids the special handling
# of 0xe5 as the first byte. $shorthash is a reference to a
# hash for the directory within which the conversion is happening.

# For each string reference in the list, strip invalid shortname
# characters (including .) in place and return 1 if the conversion was
# inexact except for case.
sub to_valid_shortchar(@) {
    my $inexact = 0;
    foreach my $i (@_) {
	$$i = uc($$i);
	$inexact = 1 if ($$i =~ s/[^!\#-\)\-0-9\@-Z^-\{\}~]+/_/g);
    }
    return $inexact;
}

sub genshortname($$$) {
    my($fullname, $shorthash, $type) = @_;
    if ($type & $VOL) {
	# The rules for volume labels are much less strict
	(my $lbl = $fullname) =~ s/[^ -~]/_/g;
	return pack('A11', $lbl);
    }

    # If this doesn't match then the name is empty...
    die unless ($fullname =~ /^(.+?)(?:\.([^.]+))?$/);
    my $head = $1;
    my $ext  = $2;
    my $inexact = to_valid_shortchar(\$head, \$ext);

    $inexact = 1 if ($head eq '' || length($head) > 8);
    $inexact = 1 if (length($ext) > 3);

    for (my $ctr = $inexact; $ctr <= 99999; $ctr++) {
	my $ctrtail = $ctr ? '~'.$ctr : '';
	my $xhead = substr($head, 0, 8-length($ctrtail));
	my $xname = pack('A8A3', $xhead.$ctrtail, $ext);
	if (!defined($shorthash->{$xname})) {
	    if ($opt{verbose} >= 2) {
		print STDERR "$opt{outfile}: short \"$xname\" for \"$fullname\"\n";
	    }
	    $shorthash->{$xname} = $fullname;
	    return $xname;
	}
    }

    die "$opt{outfile}: directory too long\n";
}

# Compute directory sizes and generate the sorted list of
# directory entries, and assign long and short names
sub prep_directories($) {
    my($root) = @_;

    foreach my $d (@{$root->{nodes}->{$DIR}}) {
	my @filelist = sort {
	    $a->{type} <=> $b->{type} || $a->{name} cmp $b->{name}
        } values(%{$d->{files}});
	$d->{filelist} = \@filelist;

	my $e = defined($d->{up}) ? 2 : 0; # . and .. for non-root
	my %shorthash;

	# One entry for each 13 UTF-16 codepoints, plus one
	foreach my $f (@filelist) {
	    $f->{longname} = genlongname($f->{name});
	    $f->{shortname} = genshortname($f->{name}, \%shorthash, $f->{type});
	    $e += length($f->{longname})/26 + 1;
	}
	$d->{size} = $e << 5;
    }
}

sub count_clusters($$) {
    my($root, $cshift) = @_;
    my $clust = 0;
    my $csize = 512 << $cshift;
    # Iterate over all nodes of all types
    foreach my $f (map { @$_ } values(%{$root->{nodes}})) {
	$clust += div_up($f->{size}, $csize);
    }
    return $clust;
}

# GPT partition types
my @gpt_types = (
    # Microsoft basic data type
    guid(0xebd0a0a2, 0xb9e5, 0x4433, 0x87c0, 0x68b6b72699c7),
    # EFI system type
    guid(0xc12a7328, 0xf81f, 0x11d2, 0xba4b, 0x00a0c93ec93b)
);

# Create preliminary format parameters for a specific cluster size.
# These will be made exact by finalize_format_params() later.
sub get_format_params($$) {
    my($root, $cshift) = @_;
    my $csize = 1 << $cshift;
    my $cbytes = $csize << 9;

    my $c = count_clusters($root, $cshift);
    my $fattype;
    my $nfats = 2;

    # Reserved space; if the "extra files" part is set make sure there is at
    # least one free cluster per file, and enough space to put any
    # reserved files in subdirectories.
    my @res = $opt{reserve} ? @{$opt{reserve}} : (0);
    $c += max($res[0] >> ($cshift+9), $res[1]);
    my $resdir = ($res[1] * (div_up($opt{namelen},13) + 1)) << 5;
    $c += div_up($resdir, $cbytes);

    # Subtract the cluster count for the root directory for the moment;
    # add them back later after FAT-type-specific modifications.
    my $rootclusts = div_up($root->{size}, $cbytes);
    $c -= $rootclusts;

    my $sectors = $c << $cshift;

    # Nybbles! per FAT entry (using bits here can cause overflow
    # on 32-bit platforms.)
    if ($c < 0xff5) {
	# FAT12
	$fattype = 12;
    } elsif ($c < 0xfff5) {
	# FAT16
	$fattype = 16;
    } elsif ($c < 0x0ffffff5) {
	# FAT32
	$fattype = 32;
	# Require cluster size >= 4096 and size 512MiB+; some
	# versions of Windows apparently have problems othersie
	return undef if ($cshift < 3 || $sectors < 512*2048);
	# Root directory is a cluster chain
	$c += $rootclusts;
    } else {
	# Invalid cshift; filesystem doesn't fit
	return undef;
    }

    # Size of each FAT in bytes
    my $fatsize = (($c+2) * $fattype + 1) >> 3;

    # Assume each FAT is padded to a cluster size.
    $fatsize = align_up($fatsize, $cbytes) >> 9;
    $sectors += $nfats*$fatsize;

    # Reserved sectors (in the FAT sense)
    my $resv = max(($fattype < 32) ? 1 : 32, $csize);
    $sectors += $resv;

    # The root directory, if not FAT32
    if ($fattype < 32) {
	$root->{size} += $resdir;
	$sectors += align_up($root->{size}, $cbytes) >> 9;
    }

    # Dummy geometry
    my $hs = [255, 63];

    # Suitable MBR type
    my $mbrtype;
    if ($opt{efi}) {
	$mbrtype = 0xef;
    } elsif ($fattype == 12) {
	$mbrtype = 0x01;
    } elsif ($fattype == 16) {
	$mbrtype =
	    $sectors < 0x10000 ? 0x04 :
	    $sectors < (($hs->[0]*$hs->[1]) << 10) ? 0x06 : 0x0e;
    } else {
	$mbrtype = 0x0c;
    }
    # Generated filesystem image parameters. May be an overestimate.
    return {
	'root' => $root,
	'sectors' => $sectors, 'cshift' => $cshift,
	'csectors' => 1 << $cshift, 'cbytes' => 512 << $cshift,
	'cbshift' => $cshift + 9, 'fattype' => $fattype,
	'resv' => $resv, 'nfats' => $nfats, 'fatsize' => $fatsize,
	'clust' => $c, 'secshift' => 9, 'sector' => 512,
	'mbrtype' => $mbrtype, 'gpttype' => $gpt_types[!!$opt{efi}],
	'media' => 0xf8, 'hs' => $hs
    };
}

# Update the format parameters after the disk layout is complete
sub finalize_format_params($$$) {
    my($root, $startsec, $fssec) = @_;
    my $parm = $root->{parm};
    $parm->{hidden}  = $startsec;

    my $prefixsec = $parm->{resv} + $parm->{fatsize} * $parm->{nfats};
    if (!$root->{clustno}) {
	$prefixsec += $root->{paddedsize} >> $parm->{secshift};
    }

    # Offset to the data area in *sectors*
    $parm->{dataoffset} = ($startsec + $prefixsec) << $parm->{secshift};

    # Compute the final size of the filesystem
    my $fattypemax = (1 << $parm->{fattype}) - 12;
    my $fatsizemax = ($parm->{fatsize} << ($parm->{secshift} + 3))
	/ $parm->{fattype};
    my $spacemax = ($fssec - $prefixsec) >> $parm->{cshift};

    $parm->{clust}   = min($spacemax, $fattypemax, $fatsizemax);
    $parm->{sectors} = $prefixsec + ($parm->{clust} << $parm->{cshift});
}

# This walks the *subnodes* of a node of a certain type
sub populate_with($$$$) {
    my($dir, $parm, $type, $what) = @_;
    my $ret = 0;

    foreach my $de (@{$dir->{filelist}}) {
	if ($de->{type} == $type) {
	    $ret += $what->($de, $parm);
	}
	if ($de->{type} == $DIR) {
	    $ret += populate_with($de, $parm, $type, $what);
	}
    }
    return $ret;
}

# Assign cluster number to one file node
sub assign_clust($) {
    my($f) = @_;
    my $root = $f->{root};
    my $parm = $root->{parm};

    $f->{paddedsize} = align_up($f->{size}, $parm->{cbytes});
    $f->{nclust} = $f->{paddedsize} >> $parm->{cbshift};
    if (!$f->{nclust}) {
	$f->{clustno} = 0;
    } else {
	$f->{clustno} = $parm->{endclust};
	$parm->{endclust} += $f->{nclust};
	push(@{$root->{layout}}, $f);
	if ($opt{verbose} >= 3) {
	    my $clustoffs = $f->{clustno} ? $f->{clustno}-2 : -$root->{nclust};
	    printf STDERR "%s: cluster %5d @ 0x%08x (len %5d) for \"%s\"\n",
		$opt{outfile}, $f->{clustno},
		$parm->{dataoffset} + ($clustoffs << $parm->{cbshift}),
		$f->{nclust}, $f->{path} || '/';
	}
    }
    return $f->{nclust};
}

# Assign final cluster numbers and padded sizes to files and directories
sub assign_clusters($) {
    my($root) = @_;
    my $parm = $root->{parm};

    # This will contain the non-empty nodes in layout order
    $root->{layout} = [];

    $parm->{endclust} = $parm->{fattype} < 32 ? 0 : 2;
    assign_clust($root);
    $parm->{endclust} = 2 if ($parm->{fattype} < 32);
    populate_with($root, $parm, $DIR,  \&assign_clust);
    populate_with($root, $parm, $FILE, \&assign_clust);
    die if ($parm->{endclust} > $parm->{clust} + 2);
}

# Emit one FAT entry. $hold should be a reference to a scalar
# used for the even-numbered (first) part of a FAT12 pair.
# The number should be masked so that the special numbers at the end
# of the number range can be represeented by -9 to -1.
sub emit_fat12($$$) {
    my($out, $num, $hold) = @_;

    $num &= 0xfff;

    if (!defined($$hold)) {
	$$hold = $num;
	return 0;
    }

    $num <<= 12;
    $num |= $$hold;
    undef($$hold);
    print $out pack('vC', $num & 0xffff, $num >> 16);
    return 3;
}
sub emit_fat16($$$) {
    my($out, $num, $hold) = @_;
    print $out pack('v', $num & 0xffff);
    return 2;
}
sub emit_fat32($$$) {
    my($out, $num, $hold) = @_;
    print $out pack('V', $num & 0x0fffffff);
    return 4;
}

sub emit_one_fat($) {
    my($parm) = @_;
    my $out = $parm->{out};
    my %emit_func = (
	12 => \&emit_fat12,
	16 => \&emit_fat16,
	32 => \&emit_fat32
    );
    my $emit = $emit_func{$parm->{fattype}};
    my $hold;
    my $bytes = 0;

    # The two special entries at the start
    $bytes += $emit->($out, $parm->{media} - 256, \$hold);
    $bytes += $emit->($out, -1, \$hold);

    my $clustno = 2;
    foreach my $f (@{$parm->{layout}}) {
	next if (!$f->{clustno});		# No cluster chain
	die if ($f->{clustno} != $clustno);	# This would be bad...
	my $nclust = $f->{nclust};
	while (--$nclust) {
	    # Emit the *next* cluster number
	    $bytes += $emit->($out, ++$clustno, \$hold);
	}
	$bytes += $emit->($out, -1, \$hold); # End of cluster chain
	$clustno++;
    }

    # Flush any partial output
    while (defined($hold)) {
	$bytes += $emit->($out, 0, \$hold);
    }

    $bytes += emitzero($out, ($parm->{fatsize} << 9) - $bytes);
    return $bytes;
}

# Maximum chunk size for writezero() and emit_file()
my $BUFSIZ = 1024*1024;

sub emit($@) {
    my $fh = shift(@_);
    my $bytes = 0;

    foreach my $s (@_) {
	$bytes += length($s);
	print $fh $s;
    }

    return $bytes;
}

sub emitzero($$) {
    my($fh, $bytes) = @_;
    my $left = $bytes;

    while ($left) {
	my $chunk = min($left, $BUFSIZ);
	print $fh ("\0" x $chunk);
	$left -= $chunk;
    }

    return $bytes;
}

sub dosdate($) {
    my($time) = @_;

    my @lt = localtime($time);

    $lt[5] -= 80;		# Convert year to 1980-based
    $lt[4] += 1;		# Convert month to 1-based

    if ($lt[5] < 0) {
	@lt = (0, 0, 0, 1, 1, 0);
    } elsif ($lt[5] > 127) {
	@lt = (59, 59, 23, 31, 12, 127);
    }

    return ($lt[5] << 25) + ($lt[4] << 21) + ($lt[3] << 16) +
	($lt[2] << 11) + ($lt[1] << 5) + ($lt[0] >> 1);
}

sub node_date($) {
    my($node) = @_;

    do {
	if (defined($node->{date})) {
	    return $node->{date};
	}
	$node = $node->{up};
    } while (defined($node));

    return 0;
}

sub dir_shortent($$$$$) {
    my($name, $attr, $date, $clustno, $size) = @_;

    $size = 0 if ($attr & ($DIR|$VOL));

    my $datetime = dosdate($date);
    return pack('A11Ca8vVvV', $name, $attr, '',
		$clustno >> 16, $datetime, $clustno & 0xffff, $size);
}

sub dir_longent($$) {
    my($longname, $shortent) = @_;

    my $namesum = 0;
    foreach my $nb (unpack('C11', $shortent)) {
	$namesum = (($namesum & 1) << 7) + ($namesum >> 1) + $nb;
	$namesum &= 0xff;
    }

    my $longpos = length($longname);
    my $longctr = ($longpos/26) | 0x40;
    my $longent = '';
    while ($longctr) {
	$longpos -= 26;
	$longent .= pack('Ca10CCCa12va4', $longctr,
			 substr($longname, $longpos, 10),
			 0x0f, 0, $namesum,
			 substr($longname, $longpos+10, 12),
			 0,
			 substr($longname, $longpos+22, 4));
	$longctr = ($longctr & 0x3f) - 1;
    }

    return $longent . $shortent;
}

sub emit_direntry($$) {
    my($f, $parm) = @_;

    my $attr = ($f->{type} & ($DIR|$VOL)) | $f->{flags};
    my $ent = dir_shortent($f->{shortname}, $attr, node_date($f),
			   $f->{clustno}, $f->{size});
    $ent = dir_longent($f->{longname}, $ent);

    return emit($parm->{out}, $ent);
}

# Emit the contents of a directory
sub emit_dir {
    my($dir, $parm) = @_;
    my $de;

    my $up = $dir->{up};
    my $bytes = 0;

    # Special entries at the beginning
    if (defined($up)) {
	# Not the root directory, emit . and ..
	my $dirdate = $dir->{date} = node_date($dir);

	$de  = dir_shortent('.',  $DIR, $dirdate, $dir->{clustno}, 0);

	# For some stupid reasons .. is supposed to have 0 in the cluster
	# pointer when it points to the root directory even on FAT32...
	my $upptr = defined($up->{up}) ? $up->{clustno} : 0;
	$de .= dir_shortent('..', $DIR, $dirdate, $upptr,  0);
	$bytes = emit($parm->{out}, $de);
    }

    # The regular directory entry list, already sorted
    foreach my $f (@{$dir->{filelist}}) {
	$bytes += emit_direntry($f, $parm);
    }

    die if ($bytes != $dir->{size});
    $bytes += emitzero($parm->{out}, $dir->{paddedsize} - $bytes);
    return $bytes;
}

# Copy the contents of a file
sub emit_file {
    my($f, $parm) = @_;
    my $sizeleft = $f->{size};
    my $cpad = $f->{paddedsize} - $sizeleft;
    my $bytes = 0;

    return if (!$sizeleft);	# Empty file

    my $out = $parm->{out};

    my $in;
    if (open($in, '<', $f->{inpath})) {
	binmode($in);
	while ($sizeleft) {
	    my $buf;
	    my $chunk = read($in, $buf, min($BUFSIZ, $sizeleft));
	    last if (!$chunk);
	    $bytes += emit($out, $buf);
	    $sizeleft -= $chunk;
	}
	close($in);
    }

    if ($sizeleft) {
	print STDERR "%s: %s: %s\n", $opt{outfile}, $f->{inpath}, $!;
	$err++;
    }

    $bytes += emitzero($out, $f->{paddedsize} - $bytes);
    return $bytes;
}

# Generate the FAT superblock
sub emit_superblock($$) {
    my($root, $parm) = @_;
    my $fat = $parm->{fattype};

    my $sec32 = $parm->{sectors};
    my $sec16 = ($fat < 32 && $sec32 <= 0xffff) ? $sec32 : 0;

    my $bs = pack('CvA8vCvCvvCvvvVV',
		  0xe9, 0x1fe-length($KILLBOOT)-3, $opt{creator},
		  $parm->{sector},
		  $parm->{csectors}, $parm->{resv}, $parm->{nfats},
		  $root->{clustno} ? 0 : $root->{paddedsize} >> 5,
		  $sec16, $parm->{media},
		  $fat < 32 ? $parm->{fatsize} : 0,
		  $parm->{s}->[1], $parm->{hs}->[0], $parm->{hidden}, $sec32);
    my $backupsb = 6;

    if ($fat >= 32) {
	# Weirdly injected in the middle of the FAT12/16 boot sector
	$bs .= pack('VvvVvva12', $parm->{fatsize}, 0, 0x0000,
		    $root->{clustno}, 1, $backupsb, '');
    }

    $bs .= pack('CCCVA11A8', 0x80, 0, 0x29, $root->{volid},
		$root->{vollbl}->{shortname}, "FAT$fat");

    $bs .= ("\0" x (0x1fe - length($KILLBOOT) - length($bs)));
    $bs .= $KILLBOOT . pack('v', 0xaa55);

    my $out = $parm->{out};
    my $bytes = emit($out, $bs);

    if ($fat >= 32) {
	my $fsinfo = pack('A4a480A4VVa12V',
			  'RRaA', '', 'rrAa',
			  $parm->{clust} - $parm->{endclust} + 2,
			  $parm->{endclust},
			  '', 0xaa550000);
	$bytes += emit($out, $fsinfo);
	$bytes += emitzero($out, ($backupsb - 2) << 9);
	$bytes += emit($out, $bs, $fsinfo);
    }
    $bytes += emitzero($out, ($parm->{resv} << $parm->{secshift}) - $bytes);
    return $bytes;
}

# Create long and short volume labels.
sub create_vol_label($) {
    my($root) = @_;

    $root->{volid} = unpack('V', rand_bytes(4));

    my $vol = $opt{volname};
    $vol = 'EFI BOOT' if (!defined($vol) && $opt{efi});
    $root->{vollbl} = {	'name' => decode_utf8($vol), 'up' => $root };
    set_node_type($root->{files}->{' :vol'} = $root->{vollbl}, $VOL)
	unless ($vol eq '');
}

sub make_filesystem($) {
    my($root) = @_;

    create_vol_label($root);
    prep_directories($root);

    # Compute a suitable cluster shift.
    my $parm = undef;
    for (my $cs = 0; $cs < 7; $cs++) {
	my $thisparm = get_format_params($root, $cs);
	next unless (defined($thisparm));
	if ($opt{verbose} >= 3) {
	    printf STDERR "trial: clust %3d: FAT%d, sectors %8d, clusters %8d\n",
		1 << $cs, $thisparm->{fattype}, $thisparm->{sectors},
		$thisparm->{clust};
	}
	if (!defined($parm) || ($thisparm->{sectors} < $parm->{sectors})) {
	    $parm = $thisparm;
	}
	# Avoid 128-sector clusters unless we really need them
	last if (defined($parm) && $cs >= 6);
    }

    die "$opt{outfile}: filesystem too large\n" unless (defined($parm));
    $root->{parm} = $parm;

    # Cluster bytes
    my $csectors = $parm->{csectors};

    # Block alignment in sectors
    my $align     = $csectors;
    my $gptsize   = div_up($opt{gptent}, $parm->{sector} >> 7);
    my $startsec  = 0;
    my $endsec    = 0;
    if ($opt{part} == $ANYPART) {
	$opt{part} = $opt{efi} ? $GPT : $MBR;
    } elsif (!$opt{part}) {
	$opt{part} = $opt{efi} ? $GPT : $FLAT;
    }
    if ($opt{part} == $GPT) {
	$startsec   = $gptsize + 2; # +2 for PMBR, header
	$endsec     = $gptsize + 1;
    } elsif ($opt{part} == $MBR) {
	$startsec = 1;
    }
    # Initial partition table + alignment + space for backup gpt if necessary
    my $sectors   = $parm->{sectors} + $startsec + $endsec;
    $sectors      = align_up($sectors, $align);
    $endsec       = $sectors - $endsec;
    my $fssec     = $endsec  - $startsec;

    # Update with the actually generated layout
    finalize_format_params($root, $startsec, $fssec);
    if ($opt{verbose} >= 2) {
	printf STDERR "%s: FAT%d, %d sectors, %d clusters * %d bytes\n".
	    "%s: filesystem @ 0x%08x, data @ 0x%08x\n",
	    $opt{outfile}, $parm->{fattype}, $fssec, $parm->{clust},
	    $parm->{cbytes},
	    $opt{outfile}, $startsec << $parm->{secshift}, $parm->{dataoffset};
    }
    assign_clusters($root);
    if ($opt{verbose} >= 1) {
	printf STDERR "%s: %d/%d clusters free\n",
	    $opt{outfile}, $parm->{clust} - ($parm->{endclust}-2),
	    $parm->{clust};
    }

    # Output the image
    my $out;
    if ($opt{outfile} eq '-') {
	open($out, '&>', \*STDOUT);
    } else {
	open($out, '>', $opt{outfile});
    }
    die "$opt{outfile}: $!\n" unless (defined($out));
    binmode($out);
    $parm->{out} = $out;

    # Create the partition table
    my @part; # MBR, GPT header, GPT array, backup GPT header
    if ($opt{part} == $GPT) {
	@part = gen_gpt($sectors, $startsec, $fssec, $parm->{gpttype},
			$gptsize, $root->{vollbl}->{name}, $parm->{hs});
    } elsif ($opt{part} == $MBR) {
	$part[0] = gen_mbr($startsec, $fssec, $parm->{mbrtype},
			   $parm->{hs}, $parm->{active});
    }

    my $bytes = emit($out, @part[0 ... 2]);
    $bytes += emitzero($out, ($startsec << 9) - $bytes);
    die unless ($bytes == ($startsec << 9));

    # The boot sector/superblock
    $bytes += emit_superblock($root, $parm);

    # The FATs
    for (my $i = 0; $i < $parm->{nfats}; $i++) {
	$bytes += emit_one_fat($parm);
    }

    # Root directory, subdirectories, files
    $bytes += emit_dir($root, $parm);
    $bytes += populate_with($root, $parm, $DIR,  \&emit_dir);
    $bytes += populate_with($root, $parm, $FILE, \&emit_file);

    # Finally, output the backup GPT
    $bytes += emitzero($out, ($endsec << 9) - $bytes);
    $bytes += emit($out, @part[2 ... 3]);

    die unless ($bytes == ($sectors << 9));
    close($out);
}

sub get_arg($$;$) {
    my($args,$opt,$optional) = @_;

    if ($opt =~ /^-.*?=(.*)$/) {
	return $1;
    }
    return undef if ($optional);
    my $arg = shift(@$args);
    if (!defined($arg)) {
	die "$0: option -$opt requires an argument\n";
    }
    return $arg;
}
sub get_arg_uints($$;$$) {
    my($args,$opt,$cmin,$cmax) = @_;
    $cmin = 1 unless (defined($cmin));
    $cmax = $cmin unless ($cmax > $cmin);

    my $arg = get_arg($args, $opt, $cmin < 1);
    return () unless (defined($arg));

    my $err;
    my @ns;
    foreach my $a (split(/,/, $arg)) {
	if ($a =~ /^\s*(0x[0-9a-f]|[0-9]+)\s*([kmgtpe])?\s*$/i) {
	    my $suf = lc($2);
	    my $n = $1;
	    $n = ($n =~ /^0x/i) ? hex($n) : $n+0;
	    $n <<= 10 * index(' kmgtpe', $suf);
	    push(@ns, $n);
	} else {
	    $err++;
	}
    }
    $err++ if (scalar(@ns) < $cmin || scalar(@ns) > $cmax);
    die "$0: invalid argument to -$opt: $arg\n" if ($err);
    return @ns;
}

sub do_options($@) {
    my $args = shift(@_);	# Argument list pointer

    foreach my $opt (@_) {
	my $truth = 1;
	$truth = 0 if ($opt =~ s/^-no-/-/);

	if ($opt =~ /^(?:o|-output)$/) {
	    $opt{output} = $truth ?
		get_arg($args, $opt) : File::Spec->devnull();
	} elsif ($opt =~ /^(?:e|-efi|-uefi)$/) {
	    $opt{efi} = $truth;
	} elsif ($opt =~ /^(?:g|-gpt)$/) {
	    if ($truth) {
		$opt{part} = $GPT;
		my @ent = get_arg_uints($args, $opt, 0);
		$opt{gptent} = $ent[0] if ($ent[0]);
	    } else {
		$opt{part} = $FLAT unless ($opt{part} == $MBR);
	    }
	} elsif ($opt =~ /^(?:a|-active|-boot(able)?)$/) {
	    $opt{active} = $truth;
	} elsif ($opt =~ /^(?:m|-mbr)$/) {
	    if ($truth) {
		$opt{part} = $MBR;
	    } else {
		$opt{part} = $FLAT unless ($opt{part} == $GPT);
	    }
	} elsif ($opt =~ /^(?:f|-flat)$/) {
	    if ($truth) {
		$opt{part} = $FLAT;
	    } else {
		$opt{part} = $ANYPART if ($opt{part} == $FLAT);
	    }
	} elsif ($opt =~ /^(?:p|-part)$/) {
	    if ($truth) {
		$opt{part} = $ANYPART unless ($opt{part} > $ANYPART);
	    } else {
		$opt{part} = $FLAT;
	    }
	} elsif ($opt =~ /^(?:r|-reserve)$/) {
	    $opt{reserve} = $truth ? [get_arg_uints($args,$opt,1,2)] : undef;
	} elsif ($opt =~ /^(?:v|-verbose)$/) {
	    $opt{verbose} = $truth ? $opt{verbose}+1 : 0;
	} elsif ($opt =~ /^(?:q|-quiet)$/) {
	    $opt{verbose} = $truth ? 0 : max($opt{verbose}, 1);
	} elsif ($opt =~ /^(?:L|n|-label|-name)$/) {
	    $opt{volname} = $truth ? get_arg($args,$opt) : undef;
	} elsif ($opt =~ /^(?:C|-creator)$/) {
	    $opt{creator} = $truth ? get_arg($args,$opt) : undef;
	} elsif ($opt =~ /^(?:W|-(win(.*)))$/) {
	    $opt{creator} = $2 ne '' ? uc($1) : 'WINNT4.1' if ($truth);
	} else {
	    die "$0: unknown option: -$opt\n";
	}
    }
}

sub parse_options(@_) {
    my(@args) = @_;
    my $output;

    # Defaults and environment variable overrides
    $opt{verbose} = $ENV{'V'};
    $opt{volname} = $ENV{'VOLNAME'};
    $opt{creator} = 'FatImage';
    $opt{namelen} = 64;		# Assumed maximum length per reserved file
    $opt{gptent}  = 1;		# Minimum number of GPT entries

    while (defined(my $arg = $args[0])) {
	last if ($arg !~ /^-((-?).*)$/);
	shift(@args);
	if ($2) {
	    last if ($1 eq '-');
	    do_options(\@args, $1);
	} else {
	    do_options(\@args, split(//, $1));
	}
    }

    $opt{outfile} = shift(@args) unless (defined($opt{outfile}));
    return @args;		# Input files
}

my(@inputs) = parse_options(@ARGV);
if (!scalar(@inputs)) {
    die <<EOF;
Usage: $0 [options] outfile input_path[::[destination]] ...
       Inputs can be files or directories.
       :: alone as a suffix indicates that the entire input_path
       should be used as the destination name, not just its contents.
EOF
}

# Hopefully correct...?!
binmode(STDERR, ':encoding(UTF-8)');

my $root = read_inputs(@inputs);
exit(1) if ($err);

make_filesystem($root);
exit(0);
