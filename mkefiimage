#!/usr/bin/perl
# <add SPDX header here>
# Copyright 2025 Intel Corporation

use strict;
use integer;
use v5.16;
use utf8;
no indirect;

use Crypt::Random::Source;
use Digest::CRC qw(crc32);
use Encode;
use Fcntl qw(:DEFAULT :mode);
use File::Spec;
use File::Temp qw(tempfile);
use IO::Handle;
use IPC::Open3;

my $verbose = $ENV{'V'};
my $volname = $ENV{'VOLNAME'} || 'EFI BOOT';

my($outfile, @inputs) = @ARGV;

if (!scalar(@inputs)) {
    die <<EOF;
Usage: $0 outfile input_path[::[destination]] ...
       Inputs can be files or directories.
       :: alone as a suffix indicates that the entire input_path
       should be used as the destination name, not just its contents.
EOF
}

# Hopefully correct...
binmode(STDERR, ':encoding(UTF-8)');

# The FAT and GPT Unicode encoding
my $FATUNI = Encode::find_encoding('UTF-16LE');

# Convert a string to "Unicode" (UTF-16LE) as used by FAT and EFI
sub to_uni($) {
    my($s) = @_;
    return Encode::encode($FATUNI, $s, Encode::LEAVE_SRC);
}

sub min(@) {
    my $x;
    foreach my $y (@_) {
	next unless (defined($y));
	$x = $y if (!defined($x) || $y < $x);
    }
    return $x;
}
sub max(@) {
    my $x;
    foreach my $y (@_) {
	next unless (defined($y));
	$x = $y if (!defined($x) || $y > $x);
    }
    return $x;
}

sub align_down($$) {
    my($val, $align) = @_;
    return $val - ($val % $align);
}
sub align_up($$) {
    my($val, $align) = @_;
    return align_down($val + $align - 1, $align);
}

# Create a random (type 4) GUID
# For Crypt::Random::Source < 0.13 using get_strong() would be better
sub rand_bytes($) {
    my($count) = @_;

    if (Crypt::Random::Source->VERSION < 0.13) {
	return Crypt::Random::Source::get_strong($count);
    } else {
	return Crypt::Random::Source::get_weak($count);
    }
}

# Yeah, the byte ordering here is weird as heck
sub guid($$$$$) {
    my($a,$b,$c,$d,$e) = @_;
    return pack('VvvQ>', $a, $b, $c, ($d << 48) | $e);
}

sub rand_guid() {
    my @b = unpack('C*', rand_bytes(16));
    $b[7] = ($b[7] & 0x0f) | 0x40; # Version 4 (random)
    $b[8] = ($b[8] & 0x3f) | 0x80; # Variant 1
    return pack('C*', @b);
}

#
# Create a minimal GPT partition table with one single partition.
# Return a vector containing the PMBR, the GPT header,
# the backup GPT header, and the GPT array.
#
# $gpt_len if set indicates the size of the GPT array in sectors.
#
my $efi_system_type
    = guid(0xc12a7328, 0xf81f, 0x11d2, 0xba4b, 0x00a0c93ec93b);

sub gen_gpt($$$;$$$$) {
    my($disk_len, $part_start, $part_len, $part_type,
       $part_name, $gpt_len, $hs) = @_;
    my @blks = (undef) x 4;

    $part_type = $efi_system_type unless (defined($part_type));
    $gpt_len = 1 unless (defined($gpt_len));
    $hs = [255, 63] unless (defined($hs));

    # PMBR
    my $end_lba = min($disk_len-1,0xffffffff);

    my $end_s    = ($end_lba % $hs->[1]) + 1;
    my $end_h    = ($end_lba/$hs->[1]) % $hs->[0];
    my $end_c    = $end_lba/($hs->[0]*$hs->[1]);
    if ($end_c > 1023) {
	($end_c, $end_h, $end_s) = (1023, $hs->[0] - 1, $hs->[1]);
    }

    $blks[0] = ("\0" x 446) .
	pack('CCCCCCCCVV', 0, 0, 2, 0, 0xee,
	     $end_h, (($end_c >> 2) & 0xc0) | $end_s,
	     $end_c & 0xff, 1, $end_lba) .
	("\0" x 48)."\x55\xaa";

    # GPT partition array
    $blks[3] = $part_type . rand_guid() .
	pack('Q<Q<Q<a142v', $part_start, $part_start + $part_len - 1, 1,
	     to_uni($part_name), 0);
    $blks[3] .= ("\0" x (512*$gpt_len - length($blks[3])));
    my $array_crc = crc32($blks[3]);

    # GPT headers (primary and alternate)
    my $disk_guid = rand_guid();
    for (my $i = 1; $i <= 2; $i++) {
	my($here, $there, $array);
	if ($i == 1) {
	    $here  = 1;
	    $there = $disk_len - 1;
	    $array = $here + 1;
	} else {
	    $here  = $disk_len - 1;
	    $there = 1;
	    $array = $here - $gpt_len;
	}

	$blks[$i] = 'EFI PART'.
	    pack('VVVVQ<Q<Q<Q<', 0x10000, 92, 0, 0,
		 $here, $there, $gpt_len+2,  $disk_len-$gpt_len-2) .
	    $disk_guid .
	    pack('Q<VVV', $array, $gpt_len << 2, 128, $array_crc);

	# Insert the header CRC
	my $hdr_crc = crc32($blks[$i]);
	substr($blks[$i], 16, 4) = pack('V', $hdr_crc);
	$blks[$i] .= ("\0" x (512 - length($blks[$i])));
    }

    return @blks;
}

# Create a normalization of a pathname as a list suitable for
# inserting in the directory tree.
sub pathlist($;$) {
    my($path, $from_host) = @_;
    my @rawpath;
    my($curdir, $updir);

    if ($from_host) {
	my @sp   = File::Spec->splitpath($path);
	my $cp   = File::Spec->catpath(undef, $sp[1], $sp[2]);
	@rawpath = File::Spec->splitdir($cp);
	$curdir  = File::Spec->curdir();
	$updir   = File::Spec->updir();
    } else {
	@rawpath = split(/[\/\\]+/, $path);
	$curdir  = '.';
	$updir   = '..';
    }

    my @path;
    foreach my $rp (@rawpath) {
	my $vn = $rp;
	if ($rp eq '' || $rp eq $curdir) {
	    next;
	} elsif ($rp eq $updir) {
	    pop(@path);
	} else {
	    push(@path, $rp);
	}
    }

    if (!scalar(@path)) {
	die "$0: empty path?: \"$path\"";
    }

    return @path;
}

# Error counter
my $err = 0;

# Directory entry types, and lists of nodes of each type
# Important: $VOL < $DIR < $FILE
my $VOL  = 0x08;
my $DIR  = 0x10;
my $FILE = 0x20;		# == ARCHIVE bit
my %nodes = ($DIR => [], $FILE => []);

# Normalize a filename coming from host space stripping things
# unsuitable for the FAT longname and forcing Perl to convert
# a string to characters rather than bytes
sub normalize_filename($) {
    my($vn) = @_;
    # Normalize name; this affects the retained name
    $vn = decode_utf8($vn);	# Convert to characters
    $vn =~ s/^\./_/;
    $vn =~ s/[\s\.]$/_/;
    $vn =~ tr/\"\*\/:<>?\\|/\'+;()!!/;
    return $vn;
}

# Creates or finds a node in the directory tree from a list of names
# and returns a reference to it
sub mktreenode($@) {
    my($root, @path) = @_;

    my $here = $root;

    foreach my $p (@path) {
	my $herepath = $here->{path};

	if (!$here->{type}) {
	    $here->{type}  = $DIR;
	    $here->{files} = {};
	    $here->{shorthash} = {};
	    push(@{$nodes{$DIR}}, $here);
	} elsif ($here->{type} != $DIR) {
	    print STDERR "$outfile: file and directory conflict: $herepath\n";
	    $err++;
	    return undef;
	}

	my $f = normalize_filename($p);
	my $uf = uc($f);
	my $there = $here;
	$here = $there->{files}->{$uf};
	if (!defined($here)) {
	    # New directory entry, unknown type so far
	    $here = {'up' => $there, 'name' => $f, 'path' => $herepath.'/'.$f};
	    $there->{files}->{$uf} = $here;
	}
    }

    return $here;
}

sub inputnode($$) {
    my($root, $inpath) = @_;

    my $dest;
    my @dest;
    if ($inpath =~ /^(.*)::(.*)$/) {
	$inpath = $1;
	$dest   = $2;
    }

    my @st = stat($inpath);
    if (!scalar(@st)) {
	print STDERR "$inpath: path not found\n";
	$err++;
	return;
    }

    if (!defined($dest)) {
	@dest = ();
    } elsif ($dest eq '') {
	@dest = pathlist($inpath, 1);
    } else {
	@dest = pathlist($dest, 0);
    }

    $dest = mktreenode($root, @dest);
    $dest->{inpath} = $inpath if (defined($dest));

    return $dest;
}

# Create the root directory node
sub rootdir() {
    my $root = { 'path' => undef, 'name' => undef, 'date' => time(),
		 'type' => $DIR, 'files' => {} };
    push(@{$nodes{$DIR}}, $root);
    return $root;
}

# Append a name to a directory path in host space
sub cat_path($$) {
    my($dir, $file) = @_;

    my @sp = File::Spec->splitpath($dir);
    $sp[1] = ($sp[1] eq '' || $sp[1] eq File::Spec->curdir)
	? $sp[2] : File::Spec->catdir($sp[1], $sp[2]);
    $sp[2] = $file;
    return File::Spec->catpath(@sp);
}

# Add an input file or directory to a directory node
sub add_input($;$) {
    my($dest, $inpath) = @_;
    return undef unless (defined($dest));

    $inpath = $dest->{inpath} unless (defined($inpath));

    my @st = stat($inpath);

    if (!scalar(@st)) {
	print STDERR "$outfile: input not found: $inpath\n";
	return;
    }
    my $mode = $st[2];

    $dest->{date}  = $st[9] if ($st[9] > $dest->{date});

    if (S_ISDIR($mode)) {
	if (!$dest->{type}) {
	    $dest->{type} = $DIR;
	    $dest->{files} = {};
	    $dest->{inpath} = $inpath;
	    push(@{$nodes{$DIR}}, $dest);
	} elsif ($dest->{type} != $DIR) {
	    printf STDERR "%s: file and directory conflict: %s (%s and %s)\n",
		$outfile, $dest->{path}, $dest->{inpath}, $inpath;
	    $err++;
	    return;
	}
	my $dh;
	if (!opendir($dh, $inpath)) {
	    printf STDERR "%s: cannot scan input directory: %s: %s\n",
		$outfile, $inpath, $!;
	    $err++;
	    return;
	}
	while (defined(my $de = readdir($dh))) {
	    next if ($de eq File::Spec->curdir() || $de eq File::Spec->updir());
	    my $node = mktreenode($dest, $de);
	    add_input($node, cat_path($inpath, $de));
	}
	closedir($dh);
    } elsif (S_ISREG($mode)) {
	if ($dest->{type}) {
	    printf STDERR "%s: file%s conflict: %s (%s and %s)\n",
		$outfile, $dest->{type} eq $DIR ? ' and directory' : '',
		$dest->{path}, $dest->{inpath}, $inpath;
	    $err++;
	    return;
	}
	$dest->{type}   = $FILE;
	$dest->{size}   = $st[7];
	$dest->{inpath} = $inpath;
	$dest->{flags}  = !($mode & S_IWRITE); # Readonly bit
	push(@{$nodes{$FILE}}, $dest);
    } else {
	printf STDERR "$outfile: skipping non-regular file: $inpath\n";
	$err++;
	return;
    }
}

#
# Read all the input files
#
sub read_inputs(@) {
    my(@inputs) = @_;

    my $root = rootdir();

    foreach my $input (@inputs) {
	add_input(inputnode($root, $input));
    }

    return $root;
}

# Convert a longname to UTF-16LE and pad it
sub genlongname($) {
    my($s) = @_;

    my $u = substr(to_uni($s), 0, 255 << 1);
    my $p = (length($u) >> 1) % 13;

    if ($p) {
	$u .= "\0\0";
	$u .= "\xff\xff" x (12-$p);
    }
    return $u;
}

# Generate a short filename. For simplicity, only consider
# non-whitespace ASCII characters as valid shortname characters, even
# though that is needlessly strict. This also avoids the special handling
# of 0xe5 as the first byte. $shorthash is a reference to a
# hash for the directory within which the conversion is happening.

# For each string reference in the list, strip invalid shortname
# characters (including .) in place and return 1 if the conversion was
# inexact except for case.
sub to_valid_shortchar(@) {
    my $inexact = 0;
    foreach my $i (@_) {
	$$i = uc($$i);
	$inexact = 1 if ($$i =~ s/[^!\#-\)\-0-9\@-Z^-\{\}~]+/_/g);
    }
    return $inexact;
}

sub genshortname($$$) {
    my($fullname, $shorthash, $type) = @_;
    if ($type & $VOL) {
	# The rules for volume labels are much less strict
	(my $lbl = $fullname) =~ s/[^ -~]/_/g;
	return pack('A11', $lbl);
    }

    # If this doesn't match then the name is empty...
    die unless ($fullname =~ /^(.+?)(?:\.([^.]+))?$/);
    my $head = $1;
    my $ext  = $2;
    my $inexact = to_valid_shortchar(\$head, \$ext);

    $inexact = 1 if ($head eq '' || length($head) > 8);
    $inexact = 1 if (length($ext) > 3);

    for (my $ctr = $inexact; $ctr <= 99999; $ctr++) {
	my $ctrtail = $ctr ? '~'.$ctr : '';
	my $xhead = substr($head, 0, 8-length($ctrtail));
	my $xname = pack('A8A3', $xhead.$ctrtail, $ext);
	if (!defined($shorthash->{$xname})) {
	    if ($verbose >= 2) {
		print STDERR "$outfile: short \"$xname\" for \"$fullname\"\n";
	    }
	    $shorthash->{$xname} = $fullname;
	    return $xname;
	}
    }

    die "$outfile: directory too long\n";
}

# Compute directory sizes and generate the sorted list of
# directory entries, and assign long and short names
sub prep_directories($) {
    my($root) = @_;

    foreach my $d (@{$nodes{$DIR}}) {
	my @filelist = sort {
	    $a->{type} <=> $b->{type} || $a->{name} cmp $b->{name}
        } values(%{$d->{files}});
	$d->{filelist} = \@filelist;

	my $e = defined($d->{up}) ? 2 : 0; # . and .. for non-root
	my %shorthash;

	# One entry for each 13 UTF-16 codepoints, plus one
	foreach my $f (@filelist) {
	    $f->{longname} = genlongname($f->{name});
	    $f->{shortname} = genshortname($f->{name}, \%shorthash, $f->{type});
	    $e += length($f->{longname})/26 + 1;
	}
	$d->{size} = $e << 5;
    }
}

sub count_clusters($) {
    my($cshift) = @_;
    my $clust = 0;

    $cshift += 9;		# sectors to bytes
    my $csize = 1 << $cshift;

    foreach my $f (@{$nodes{$DIR}}, @{$nodes{$FILE}}) {
	$clust += ($f->{size} + $csize - 1) >> $cshift;
    }

    return $clust;
}

# Create preliminary format parameters for a specific cluster size.
# This function *is* allowed to overestimate.
sub get_format_params($$) {
    my($root, $cshift) = @_;
    my $csize = 1 << $cshift;

    my $c = count_clusters($cshift);
    my $fattype;
    my $nfats = 2;

    my $sectors = $c << $cshift;

    # Nybbles! per FAT entry (using bits here can cause overflow
    # on 32-bit platforms.)
    if ($c < 0xff5) {
	# FAT12
	$fattype = 12;
    } elsif ($c < 0xfff5) {
	# FAT16
	$fattype = 16;
    } elsif ($c < 0x0ffffff5) {
	# FAT32
	$fattype = 32;
	# Require cluster size >= 4096 and size 512MiB+; some
	# versions of Windows apparently have problems othersie
	return undef if ($cshift < 3 || $sectors < 512*2048);
    } else {
	# Invalid cshift; filesystem doesn't fit
	return undef;
    }

    # Size of each FAT in bytes
    my $fatsize = (($c+2) * $fattype + 1) >> 3;

    # Assume each FAT is padded to a cluster size.
    $fatsize = align_up($fatsize, $csize << 9) >> 9;
    $sectors += $nfats*$fatsize;

    # Reserved sectors
    my $resv = max(($fattype < 32) ? 1 : 32, $csize);
    $sectors += $resv;

    # Generated filesystem image parameters. May be an overestimate.
    return {
	'sectors' => $sectors, 'cshift' => $cshift,
	'csectors' => 1 << $cshift, 'cbytes' => 512 << $cshift,
	'cbshift' => $cshift + 9, 'fattype' => $fattype,
	'resv' => $resv, 'nfats' => $nfats, 'fatsize' => $fatsize,
	'clust' => $c, 'secshift' => 9, 'sector' => 512,
	'media' => 0xf8, 'h' => 255, 's' => 63
    };
}

# Update the format parameters after the disk layout is complete
sub finalize_format_params($$$$) {
    my($root, $parm, $startsec, $fssec) = @_;
    $parm->{hidden}  = $startsec;

    my $prefixsec = $parm->{resv} + $parm->{fatsize} * $parm->{nfats};

    if (!$root->{clustno}) {
	$prefixsec += $root->{paddedsize} >> $parm->{secshift};
    }

    $parm->{data} = $startsec + $prefixsec;

    # Compute the final size of the filesystem
    my $fattypemax = (1 << $parm->{fattype}) - 12;
    my $fatsizemax = ($parm->{fatsize} << ($parm->{secshift} + 3))
	/ $parm->{fattype};
    my $spacemax = ($fssec - $prefixsec) >> $parm->{cshift};

    $parm->{clust}   = min($spacemax, $fattypemax, $fatsizemax);
    $parm->{sectors} = $prefixsec + ($parm->{clust} << $parm->{cshift});
}

# This walks the *subnodes* of a node of a certain type
sub populate_with($$$$) {
    my($dir, $parm, $type, $what) = @_;
    my $ret = 0;

    foreach my $de (@{$dir->{filelist}}) {
	if ($de->{type} == $type) {
	    $ret += $what->($de, $parm);
	}
	if ($de->{type} == $DIR) {
	    $ret += populate_with($de, $parm, $type, $what);
	}
    }

    return $ret;
}

# Assign cluster number to one file node
sub assign_clust($$) {
    my($f, $parm) = @_;

    $f->{paddedsize} = align_up($f->{size}, $parm->{cbytes});
    $f->{nclust} = $f->{paddedsize} >> $parm->{cbshift};
    if (!$f->{nclust}) {
	$f->{clustno} = 0;
    } else {
	$f->{clustno} = $parm->{endclust};
	$parm->{endclust} += $f->{nclust};
	push(@{$parm->{layout}}, $f);
	if ($verbose >= 3) {
	    printf STDERR "%s: cluster %5d @ 0x%08x (len %5d) for \"%s\"\n",
		$outfile, $f->{clustno},
		($f->{data} << $parm->{secshift}) +
		(($f->{clustno}-2) << $parm->{cshift}),
		$f->{nclust}, $f->{path};
	}
    }

    return $f->{endclust};
}

# Assign final cluster numbers and padded sizes to files and directories
sub assign_clusters($$) {
    my($root, $parm) = @_;

    # This will contain the non-empty nodes in layout order
    $parm->{layout} = [];

    # These must be run in the same order as the final population,
    # so use the populate_with() helpers here too.
    if ($parm->{fattype} < 32) {
	# The root directory doesn't use "real" clusters
	$parm->{endclust} = 0;
	assign_clust($root, $parm);
	$parm->{endclust} = 2;
    } else {
	$parm->{endclust} = 2;
	assign_clust($root, $parm);
    }
    populate_with($root, $parm, $DIR,  \&assign_clust);
    populate_with($root, $parm, $FILE, \&assign_clust);

    die if ($parm->{endclust} > $parm->{clust} + 2);
}

# Emit one FAT entry. $hold should be a reference to a scalar
# used for the even-numbered (first) part of a FAT12 pair.
# The number should be masked so that the special numbers at the end
# of the number range can be represeented by -9 to -1.
sub emit_fat12($$$) {
    my($out, $num, $hold) = @_;

    $num &= 0xfff;

    if (!defined($$hold)) {
	$$hold = $num;
	return 0;
    }

    $num <<= 12;
    $num |= $$hold;
    undef($$hold);
    print $out pack('vC', $num & 0xffff, $num >> 16);
    return 3;
}
sub emit_fat16($$$) {
    my($out, $num, $hold) = @_;
    print $out pack('v', $num & 0xffff);
    return 2;
}
sub emit_fat32($$$) {
    my($out, $num, $hold) = @_;
    print $out pack('V', $num & 0x0fffffff);
    return 4;
}

sub emit_one_fat($) {
    my($parm) = @_;
    my $out = $parm->{out};
    my %emit_func = (
	12 => \&emit_fat12,
	16 => \&emit_fat16,
	32 => \&emit_fat32
    );
    my $emit = $emit_func{$parm->{fattype}};
    my $hold;
    my $bytes = 0;

    # The two special entries at the start
    $bytes += $emit->($out, $parm->{media} - 256, \$hold);
    $bytes += $emit->($out, -1, \$hold);

    my $clustno = 2;
    foreach my $f (@{$parm->{layout}}) {
	next if (!$f->{clustno});		# No cluster chain
	die if ($f->{clustno} != $clustno);	# This would be bad...
	my $nclust = $f->{nclust};
	while (--$nclust) {
	    # Emit the *next* cluster number
	    $bytes += $emit->($out, ++$clustno, \$hold);
	}
	$bytes += $emit->($out, -1, \$hold); # End of cluster chain
	$clustno++;
    }

    # Flush any partial output
    while (defined($hold)) {
	$bytes += $emit->($out, 0, \$hold);
    }

    $bytes += emitzero($out, ($parm->{fatsize} << 9) - $bytes);
    return $bytes;
}

# Maximum chunk size for writezero() and emit_file()
my $BUFSIZ = 1024*1024;

sub emit($@) {
    my $fh = shift(@_);
    my $bytes = 0;

    foreach my $s (@_) {
	$bytes += length($s);
	print $fh $s;
    }

    return $bytes;
}

sub emitzero($$) {
    my($fh, $bytes) = @_;
    my $left = $bytes;

    while ($left) {
	my $chunk = min($left, $BUFSIZ);
	print $fh ("\0" x $chunk);
	$left -= $chunk;
    }

    return $bytes;
}

sub dosdate($) {
    my($time) = @_;

    my @lt = localtime($time);

    $lt[5] -= 80;		# Convert year to 1980-based
    $lt[4] += 1;		# Convert month to 1-based

    if ($lt[5] < 0) {
	@lt = (0, 0, 0, 1, 1, 0);
    } elsif ($lt[5] > 127) {
	@lt = (59, 59, 23, 31, 12, 127);
    }

    return ($lt[5] << 25) + ($lt[4] << 21) + ($lt[3] << 16) +
	($lt[2] << 11) + ($lt[1] << 5) + ($lt[0] >> 1);
}

sub node_date($) {
    my($node) = @_;

    do {
	if (defined($node->{date})) {
	    return $node->{date};
	}
	$node = $node->{up};
    } while (defined($node));

    return 0;
}

sub dir_shortent($$$$$) {
    my($name, $attr, $date, $clustno, $size) = @_;

    $size = 0 if ($attr & ($DIR|$VOL));

    my $datetime = dosdate($date);
    return pack('A11Ca8vVvV', $name, $attr, '',
		$clustno >> 16, $datetime, $clustno & 0xffff, $size);
}

sub dir_longent($$) {
    my($longname, $shortent) = @_;

    my $namesum = 0;
    foreach my $nb (unpack('C11', $shortent)) {
	$namesum = (($namesum & 1) << 7) + ($namesum >> 1) + $nb;
	$namesum &= 0xff;
    }

    my $longpos = length($longname);
    my $longctr = ($longpos/26) | 0x40;
    my $longent = '';
    while ($longctr) {
	$longpos -= 26;
	$longent .= pack('Ca10CCCa12va4', $longctr,
			 substr($longname, $longpos, 10),
			 0x0f, 0, $namesum,
			 substr($longname, $longpos+10, 12),
			 0,
			 substr($longname, $longpos+22, 4));
	$longctr = ($longctr & 0x3f) - 1;
    }

    return $longent . $shortent;
}

sub emit_direntry($$) {
    my($f, $parm) = @_;

    my $attr = ($f->{type} & ($DIR|$VOL)) | $f->{flags};
    my $ent = dir_shortent($f->{shortname}, $attr, node_date($f),
			   $f->{clustno}, $f->{size});
    $ent = dir_longent($f->{longname}, $ent);

    return emit($parm->{out}, $ent);
}

# Emit the contents of a directory
sub emit_dir {
    my($dir, $parm) = @_;
    my $de;

    my $up = $dir->{up};
    my $bytes = 0;

    # Special entries at the beginning
    if (defined($up)) {
	# Not the root directory, emit . and ..
	my $dirdate = $dir->{date} = node_date($dir);

	$de  = dir_shortent('.',  $DIR, $dirdate, $dir->{clustno}, 0);

	# For some stupid reasons .. is supposed to have 0 in the cluster
	# pointer when it points to the root directory even on FAT32...
	my $upptr = defined($up->{up}) ? $up->{clustno} : 0;
	$de .= dir_shortent('..', $DIR, $dirdate, $upptr,  0);
	$bytes = emit($parm->{out}, $de);
    }

    # The regular directory entry list, already sorted
    foreach my $f (@{$dir->{filelist}}) {
	$bytes += emit_direntry($f, $parm);
    }

    die if ($bytes != $dir->{size});
    $bytes += emitzero($parm->{out}, $dir->{paddedsize} - $bytes);
    return $bytes;
}

# Copy the contents of a file
sub emit_file {
    my($f, $parm) = @_;
    my $sizeleft = $f->{size};
    my $cpad = $f->{paddedsize} - $sizeleft;
    my $bytes = 0;

    return if (!$sizeleft);	# Empty file

    my $out = $parm->{out};

    my $in;
    if (open($in, '<', $f->{inpath})) {
	binmode($in);
	while ($sizeleft) {
	    my $buf;
	    my $chunk = read($in, $buf, min($BUFSIZ, $sizeleft));
	    last if (!$chunk);
	    $bytes += emit($out, $buf);
	    $sizeleft -= $chunk;
	}
	close($in);
    }

    if ($sizeleft) {
	print STDERR "%s: %s: %s\n", $outfile, $f->{inpath}, $!;
	$err++;
    }

    $bytes += emitzero($out, $f->{paddedsize} - $bytes);
    return $bytes;
}

# Generate the FAT superblock
my $whoami = 'mkefiimg';
sub emit_superblock($$) {
    my($root, $parm) = @_;
    my $fat = $parm->{fattype};

    my $sec32 = $parm->{sectors};
    my $sec16 = ($fat < 32 && $sec32 <= 0xffff) ? $sec32 : 0;

    my $bs = pack('CvA8vCvCvvCvvvVV',
		  0xe9, 0x1f8-3, $whoami, $parm->{sector},
		  $parm->{csectors}, $parm->{resv}, $parm->{nfats},
		  $root->{clustno} ? 0 : $root->{paddedsize} >> 5,
		  $sec16, $parm->{media},
		  $fat < 32 ? $parm->{fatsize} : 0,
		  $parm->{s}, $parm->{h}, $parm->{hidden}, $sec32);

    my $backupsb = 6;

    if ($fat >= 32) {
	# Weirdly injected in the middle of the FAT12/16 boot sector
	$bs .= pack('VvvVvva12', $parm->{fatsize}, 0, 0x0000,
		    $root->{clustno}, 1, $backupsb, '');
    }

    $bs .= pack('CCCVA11A8', 0x80, 0, 0x29, $root->{volid},
		$root->{vollbl}->{shortname}, "FAT$fat");

    $bs .= ("\0" x (0x1f8 - length($bs)));
    $bs .= "\xcd\x18\xf4\xeb\xfb\0\x55\xaa";

    my $out = $parm->{out};
    my $bytes = emit($out, $bs);

    if ($fat >= 32) {
	my $fsinfo = pack('A4a480A4VVa12V',
			  'RRaA', '', 'rrAa',
			  $parm->{clust} - $parm->{endclust} + 2,
			  $parm->{endclust},
			  '', 0xaa550000);
	$bytes += emit($out, $fsinfo);
	$bytes += emitzero($out, ($backupsb - 2) << 9);
	$bytes += emit($out, $bs, $fsinfo);
    }
    $bytes += emitzero($out, ($parm->{resv} << $parm->{secshift}) - $bytes);
    return $bytes;
}

# Create long and short volume labels
sub create_vol_label($$) {
    my($root, $vol) = @_;

    $root->{volid} = unpack('V', rand_bytes(4));
    $root->{vollbl} = {
	'name' => decode_utf8($vol), 'type' => $VOL, 'up' => $root
    };
    if ($vol ne '') {
	$root->{files}->{':vol'} = $root->{vollbl};
    }
}

sub make_filesystem($) {
    my($root) = @_;

    create_vol_label($root, $volname);
    prep_directories($root);

    # Compute a suitable cluster shift.
    my $parm = undef;
    for (my $cs = 0; $cs < 7; $cs++) {
	my $thisparm = get_format_params($root, $cs);
	next unless (defined($thisparm));
	if ($verbose >= 2) {
	    printf STDERR "clust %3d: FAT%d, sectors %8d, clust %8d\n",
		1 << $cs, $thisparm->{fattype}, $thisparm->{sectors},
		$thisparm->{clust};
	}
	if (!defined($parm) || ($thisparm->{sectors} < $parm->{sectors})) {
	    $parm = $thisparm;
	}
	# Avoid 128-sector clusters unless we really need them
	last if (defined($parm) && $cs >= 6);
    }

    die "$outfile: filesystem too large\n" unless (defined($parm));

    # Cluster bytes
    my $csectors = $parm->{csectors};

    # Block alignment in sectors
    my $align     = $csectors;
    my $gptsize   = 1;		# In sectors, standard = 32
    my $startsec  = align_up($gptsize+2, $align); # +2 for PMBR, header

    # Initial gpt + alignent + and 33 sectors for backup gpt.
    my $sectors   = $parm->{sectors} + $startsec + ($gptsize+1);
    $sectors      = align_up($sectors, $align);
    my $backupgpt = $sectors - ($gptsize+1);
    my $fssec     = $backupgpt - $startsec;

    # Update with the actually generated layout
    finalize_format_params($root, $parm, $startsec, $fssec);
    assign_clusters($root, $parm);

    # Output the image
    my $out;
    if ($outfile eq '-') {
	open($out, '&>', \*STDOUT);
    } else {
	open($out, '>', $outfile);
    }
    die "$outfile: $!\n" unless (defined($out));
    binmode($out);
    $parm->{out} = $out;

    # Create the GPT partition table
    my @gpt = gen_gpt($sectors, $startsec, $fssec, $efi_system_type,
		      $root->{vollbl}->{name},
		      $gptsize, [$parm->{h}, $parm->{s}]);

    my $bytes = emit($out, $gpt[0], $gpt[1], $gpt[3]);
    $bytes += emitzero($out, ($startsec << 9) - $bytes);

    # The boot sector/superblock
    $bytes += emit_superblock($root, $parm);

    # The FATs
    for (my $i = 0; $i < $parm->{nfats}; $i++) {
	$bytes += emit_one_fat($parm);
    }

    # Root directory, subdirectories, files
    $bytes += emit_dir($root, $parm);
    $bytes += populate_with($root, $parm, $DIR,  \&emit_dir);
    $bytes += populate_with($root, $parm, $FILE, \&emit_file);

    # Finally, output the backup GPT
    $bytes += emitzero($out, ($backupgpt << 9) - $bytes);
    $bytes += emit($out, $gpt[3], $gpt[2]);

    die unless ($bytes == ($sectors << 9));
    close($out);
}

die "$0: needs a 64-bit integer Perl interpreter\n" unless (1 << 63);

my $root = read_inputs(@inputs);
exit(1) if ($err);

make_filesystem($root);
exit(0);
