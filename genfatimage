#!/usr/bin/perl
# <add SPDX header here>
# Copyright 2025 Intel Corporation

use strict;
use integer;
use v5.16;
use utf8;
no indirect;

use Crypt::Random::Source;
use Date::Parse;
use Digest::CRC qw(crc32);
use Encode;
use Fcntl qw(:DEFAULT :mode);
use File::Spec;

die "$0 a 64-bit integer Perl interpreter is required\n" unless (1 << 63);

# Program name and version
my $myname    = 'genfatimage';
my $myversion = '0.0.1';

# Options structure
my %opt = (
    # Defaults, including ones taken from the environment.
    'verbose' => $ENV{'V'},
    'volname' => $ENV{'VOLNAME'},
    'gptent' => 1,		# Minimum number of GPT entries
    'pad' => 1,			# Pad image by default
    'backup_gpt' => 1		# Generate backup GPT
);


# Constants for partition type; the ordering matters for command-line parsing.
my $ANYPART = 0;
my $FLAT    = 1;
my $MBR     = 2;
my $GPT     = 3;

# The FAT and GPT Unicode encoding (UTF-16LE)
my $FATUNI = Encode::find_encoding('UTF-16LE');
# Convert a string to the "Unicode" as used by FAT and EFI
sub to_uni($) {
    my($s) = @_;
    return Encode::encode($FATUNI, $s, Encode::LEAVE_SRC);
}

sub min(@) {
    my $x;
    foreach my $y (@_) {
	next unless (defined($y));
	$x = $y if (!defined($x) || $y < $x);
    }
    return $x;
}
sub max(@) {
    my $x;
    foreach my $y (@_) {
	next unless (defined($y));
	$x = $y if (!defined($x) || $y > $x);
    }
    return $x;
}

sub align_down($$) {
    my($val, $align) = @_;
    return $val - ($val % $align);
}
sub align_up($$) {
    my($val, $align) = @_;
    return align_down($val + $align - 1, $align);
}
sub div_up($$) {
    my($val, $divisor) = @_;
    return ($val + $divisor - 1)/$divisor;
}

# Code to kill a BIOS boot: 1: int $0x80; hlt; jmp 1b
my $KILLBOOT = "\xcd\x18\xf4\xeb\xfb";
my $KILLOFFS = 0x180;		# Must be valid for MBR and FAT bootsector

# Create a random (type 4) GUID
# For Crypt::Random::Source < 0.13 using get_strong() would be better
sub rand_bytes($) {
    my($count) = @_;

    if (Crypt::Random::Source->VERSION < 0.13) {
	return Crypt::Random::Source::get_strong($count);
    } else {
	return Crypt::Random::Source::get_weak($count);
    }
}

# Decode optionally separated sequences of hexadecimal digits with
# a list of maximum length (set to undef for any length)
sub hexgroups($@) {
    my($s, @grps) = @_;
    my @l;
    $s =~ s/\s+//g;
    foreach my $g (@grps) {
	last if ($s eq '');
	$s =~ s/^([0-9a-f]{0,$g})[^0-9a-f\s]?//i;
	push(@l, hex($1));
    }
    return @l;
}

# Yeah, the byte ordering here is weird as heck
sub guid(@) {
    my($a,$b,$c,$d,$e) = @_;
    return pack('VvvQ>', $a, $b, $c, ($d << 48) | $e);
}
sub rand_guid() {
    my @b = unpack('C*', rand_bytes(16));
    $b[7] = ($b[7] & 0x0f) | 0x40; # Version 4 (random)
    $b[8] = ($b[8] & 0x3f) | 0x80; # Variant 1
    return pack('C*', @b);
}
sub parse_guid($) {
    my($s) = @_;
    my @h = hexgroups($s,8,4,4,4,12);
    return @h ? guid(@h) : rand_guid();
}
sub guid_str($) {
    my($guid) = @_;
    my @w = unpack('VvvnnN', $guid."\0\0");
    return sprintf('%08X-%04X-%04X-%04X-%04X%08X', @w);
}

sub to_chs($$) {
    my($lba, $chs) = @_;
    my $s = ($lba % $chs->[2]) + 1;
    my $t = $lba / $chs->[2];
    my $h = $t % $chs->[1];
    my $c = $t / $chs->[1];
    ($c,$h,$s) = (1023,$chs->[1]-1,$chs->[2]) if ($c > 1023);
    return pack('C3', $h, ($c >> 2)|$s, $c & 0xff);
}
# Create a minimal MBR partition table with one single partition.
sub gen_mbr($$$;$$$)
{
    my($part_start, $part_len, $part_type, $chs, $active, $id) = @_;
    my $part_end = min($part_start+$part_len-1, 0xffffffff);
    my $pe;
    if ($part_start <= 0xffffffff) {
	$pe = pack('Ca3Ca3VV',
		   $active ? 0x80 : 0, to_chs($part_start, $chs),
		   $part_type, to_chs($part_end, $chs), $part_start, $part_len);
    }
    return pack('Cv.a*@440a4va64v', 0xe9, $KILLOFFS-3, $KILLOFFS,
		$KILLBOOT, $id, 0, $pe, 0xaa55);
}

# Create a minimal GPT partition table with one single partition.
# Return a vector containing the PMBR, the GPT header,
# the GPT array, and the backup GPT header in that order.
# $gpt_len is the desired size of the GPT array in sectors.
sub gen_gpt($$$$$;$$$$) {
    my($disk_len, $part_start, $part_len, $part_type,
       $gpt_len, $part_name, $disk_guid, $part_guid, $chs) = @_;
    my @blks;

    # PMBR - per spec the PMBR has no disk ID
    $blks[0] = gen_mbr(1, $disk_len-1, 0xee, $chs);

    # GPT partition array
    $blks[2] = pack('a16a16Q<Q<Q<a142v.', $part_type, $part_guid,
		    $part_start, $part_start + $part_len - 1,
		    ($opt{efi} ? 1 : 0) | ($opt{active} ? 4 : 0),
		    to_uni($part_name), 0,
		    $gpt_len << 9);
    my $array_crc = crc32($blks[2]);

    # GPT headers (primary and alternate)
    my $disk_guid = rand_guid();
    my $backup_gpt = $disk_len - ($opt{backup_gpt} ? 1+$gpt_len : 0);
    my @hdrs = ([1, 1, $backup_gpt+$gpt_len, 2]);
    push(@hdrs, [3, $backup_gpt+$gpt_len, 1, $backup_gpt]) if ($opt{backup_gpt});
    foreach my $hdr (@hdrs) {
	my($i, $here, $there, $array) = @$hdr;
	$blks[$i] =
	    pack('a8VVVVQ<Q<Q<Q<a16Q<VVV', 'EFI PART', 0x10000, 92, 0, 0,
		 $here, $there, $gpt_len+2, $backup_gpt,
		 $disk_guid, $array, $gpt_len << 2, 128, $array_crc);

	my $hdr_crc = crc32($blks[$i]);
	substr($blks[$i], 16, 4) = pack('V', $hdr_crc);
	$blks[$i] .= ("\0" x (512 - length($blks[$i])));
    }

    return @blks;
}

# Create a normalization of a pathname as a list suitable for
# inserting in the directory tree.
sub pathlist($;$) {
    my($path, $from_host) = @_;
    my @rawpath;
    my($curdir, $updir);

    if ($from_host) {
	my @sp   = File::Spec->splitpath($path);
	my $cp   = File::Spec->catpath(undef, $sp[1], $sp[2]);
	@rawpath = File::Spec->splitdir($cp);
	$curdir  = File::Spec->curdir();
	$updir   = File::Spec->updir();
    } else {
	@rawpath = split(/[\/\\]+/, $path);
	$curdir  = '.';
	$updir   = '..';
    }

    my @path;
    foreach my $rp (@rawpath) {
	my $vn = $rp;
	if ($rp eq '' || $rp eq $curdir) {
	    next;
	} elsif ($rp eq $updir) {
	    pop(@path);
	} else {
	    push(@path, $rp);
	}
    }

    die "$0: empty path?: \"$path\"" if (!@path);
    return @path;
}

# Error counter
my $err = 0;

# Directory entry types, and lists of nodes of each type
# Important: $VOL < $DIR < $FILE
my $VOL  = 0x08;
my $DIR  = 0x10;
my $FILE = 0x20;		# == ARCHIVE bit

# Normalize a filename coming from host space stripping things
# unsuitable for the FAT longname and forcing Perl to convert
# a string to characters rather than bytes
sub normalize_filename($) {
    my($vn) = @_;
    # Normalize name; this affects the retained name
    $vn = decode_utf8($vn);	# Convert to characters
    $vn =~ s/^\./_/;
    $vn =~ s/[\s\.]$/_/;
    $vn =~ tr/\"\*\/:<>?\\|/\'+;()!!/;
    return $vn;
}

sub set_node_type($$;$) {
    my($node, $type, $inpath) = @_;
    if ($node->{type}) {
	if ($node->{type} != $type) {
	    printf STDERR "%s: type conflict: %s (%s and %s)\n",
		$opt{outfile}, $node->{type} eq $DIR ? ' and directory' : '',
		$node->{path}, $node->{inpath}, $inpath;
	    return 0;
	}
    } else {
	$node->{type} = $type;
	push(@{$node->{root}->{nodes}->{$type}}, $node);
	$node->{files} = {} if ($type == $DIR);
    }
    $node->{inpath} = $inpath;
    return 1;
}

# Creates or finds a node in the directory tree from a list of names
# and returns a reference to it
sub mktreenode($@) {
    my($here, @path) = @_;

    foreach my $p (@path) {
	my $herepath = $here->{path};

	if (!set_node_type($here, $DIR)) {
	    print STDERR "$opt{outfile}: type conflict: $herepath\n";
	    $err++;
	    return undef;
	}

	my $f = normalize_filename($p);
	my $uf = uc($f);
	my $there = $here;
	$here = $there->{files}->{$uf};
	if (!defined($here)) {
	    # New directory entry, unknown type so far
	    $here = {
		'root' => $there->{root}, 'up' => $there, 'name' => $f,
		'path' => $herepath.'/'.$f
	    };
	    $there->{files}->{$uf} = $here;
	}
    }

    return $here;
}

sub inputnode($$) {
    my($root, $inpath) = @_;

    $inpath =~ s/^(?:([^:]*):)?://;
    my $destpath = $1;

    my @st = stat($inpath);
    if (!@st) {
	print STDERR "$inpath: path not found\n";
	$err++;
	return;
    }

    my @dest;
    if (!defined($destpath)) {
	@dest = ();
    } elsif ($destpath eq '') {
	@dest = pathlist($inpath, 1);
    } else {
	@dest = pathlist($destpath, 0);
    }

    my $dest = mktreenode($root, @dest);
    $dest->{inpath} = $inpath if (defined($dest));
    return $dest;
}

# Create the root directory node
sub rootdir() {
    my $root = {'path' => undef, 'name' => undef};
    $root->{root} = $root;
    $root->{nodes} = { $FILE => [], $VOL => [], $DIR => [] };
    set_node_type($root, $DIR);
    return $root;
}

# Append a name to a directory path in host space
sub cat_path($$) {
    my($dir, $file) = @_;

    my @sp = File::Spec->splitpath($dir);
    $sp[1] = ($sp[1] eq '' || $sp[1] eq File::Spec->curdir)
	? $sp[2] : File::Spec->catdir($sp[1], $sp[2]);
    $sp[2] = $file;
    return File::Spec->catpath(@sp);
}

sub node_date($) {
    my($node) = @_;

    do {
	return $node->{date} if (defined($node->{date}));
    } while ($node = $node->{up});
    return 0;
}

# Add an input file or directory to a directory node
sub add_input($;$) {
    my($dest, $inpath) = @_;
    return undef unless (defined($dest));

    $inpath = $dest->{inpath} unless (defined($inpath));

    my @st = stat($inpath);
    if (!@st) {
	print STDERR "$opt{outfile}: input not found: $inpath\n";
	return;
    }
    my $mode = $st[2];

    if (S_ISDIR($mode)) {
	if (!set_node_type($dest, $DIR, $inpath)) {
	    $err++;
	    return;
	}
	my $dh;
	if (!opendir($dh, $inpath)) {
	    printf STDERR "%s: cannot scan input directory: %s: %s\n",
		$opt{outfile}, $inpath, $!;
	    $err++;
	    return;
	}
	while (defined(my $de = readdir($dh))) {
	    next if ($de eq File::Spec->curdir() || $de eq File::Spec->updir());
	    my $node = mktreenode($dest, $de);
	    add_input($node, cat_path($inpath, $de));
	}
	closedir($dh);
    } elsif (S_ISREG($mode)) {
	if (!set_node_type($dest, $FILE, $inpath)) {
	    $err++;
	    return;
	}
	$dest->{size}  = $st[7];
	$dest->{flags} = !($mode & S_IWRITE); # Readonly bit
    } else {
	printf STDERR "$opt{outfile}: skipping non-regular file: $inpath\n";
	$err++;
	return;
    }
    # Successful!
    $dest->{date} = max(node_date($dest), $st[9]);
}

#
# Read all the input files
#
sub read_inputs(@) {
    my(@inputs) = @_;

    my $root = rootdir();
    foreach my $input (@inputs) {
	add_input(inputnode($root, $input));
    }

    return $root;
}

# Convert a longname to UTF-16LE and pad it
sub genlongname($) {
    my($s) = @_;

    my $u = substr(to_uni($s), 0, 255 << 1);
    my $p = (length($u) >> 1) % 13;

    $u .= "\0\0" . ("\xff\xff" x (12-$p)) if ($p);
    return $u;
}

# Generate a short filename. For simplicity, only consider
# non-whitespace ASCII characters as valid shortname characters, even
# though that is needlessly strict. This also avoids the special handling
# of 0xe5 as the first byte. $shorthash is a reference to a
# hash for the directory within which the conversion is happening.

# For each string reference in the list, strip invalid shortname
# characters (including .) in place and return 1 if the conversion was
# inexact except for case.
sub to_valid_shortchar(@) {
    my $inexact = 0;
    foreach my $i (@_) {
	$$i = uc($$i);
	$inexact = 1 if ($$i =~ s/[^!\#-\)\-0-9\@-Z^-\{\}~]+/_/g);
    }
    return $inexact;
}

sub genshortname($$$) {
    my($fullname, $shorthash, $type) = @_;
    if ($type & $VOL) {
	# The rules for volume labels are much less strict
	(my $lbl = $fullname) =~ s/[^ -~]/_/g;
	return pack('A11', $lbl);
    }

    # If this doesn't match then the name is empty...
    die unless ($fullname =~ /^(.+?)(?:\.([^.]+))?$/);
    my $head = $1;
    my $ext  = $2;
    my $inexact = to_valid_shortchar(\$head, \$ext);

    $inexact = 1 if ($head eq '' || length($head) > 8);
    $inexact = 1 if (length($ext) > 3);

    for (my $ctr = $inexact; $ctr <= 99999; $ctr++) {
	my $ctrtail = $ctr ? '~'.$ctr : '';
	my $xhead = substr($head, 0, 8-length($ctrtail));
	my $xname = pack('A8A3', $xhead.$ctrtail, $ext);
	if (!defined($shorthash->{$xname})) {
	    if ($opt{verbose} >= 2) {
		print STDERR "$opt{outfile}: short \"$xname\" for \"$fullname\"\n";
	    }
	    $shorthash->{$xname} = $fullname;
	    return $xname;
	}
    }

    die "$opt{outfile}: directory too long\n";
}

# Compute directory sizes and generate the sorted list of
# directory entries, and assign long and short names
sub prep_directories($) {
    my($root) = @_;

    foreach my $d (@{$root->{nodes}->{$DIR}}) {
	my @filelist = sort {
	    $a->{type} <=> $b->{type} || $a->{name} cmp $b->{name}
        } values(%{$d->{files}});
	$d->{filelist} = \@filelist;

	my $e = defined($d->{up}) ? 2 : 0; # . and .. for non-root
	my %shorthash;

	# One entry for each 13 UTF-16 codepoints, plus one
	foreach my $f (@filelist) {
	    $f->{longname} = genlongname($f->{name});
	    $f->{shortname} = genshortname($f->{name}, \%shorthash, $f->{type});
	    $e += length($f->{longname})/26 + 1;
	}
	$d->{size} = $e << 5;
    }
}

sub count_clusters($$) {
    my($root, $cshift) = @_;
    my $clust = 0;
    my $csize = 512 << $cshift;
    # Iterate over all nodes of all types
    foreach my $f (map { @$_ } values(%{$root->{nodes}})) {
	$clust += div_up($f->{size}, $csize);
    }
    return $clust;
}

# GPT partition types
my @gpt_types = (
    # Microsoft basic data type
    guid(0xebd0a0a2, 0xb9e5, 0x4433, 0x87c0, 0x68b6b72699c7),
    # EFI system type
    guid(0xc12a7328, 0xf81f, 0x11d2, 0xba4b, 0x00a0c93ec93b)
);

# Create preliminary format parameters for a specific cluster size.
# These will be made exact by finalize_format_params() later.
sub get_format_params($$) {
    my($root, $cshift) = @_;
    my $secshift = 9;
    my $sector = 1 << $secshift;
    my $csize = 1 << $cshift;
    my $cbshift = $cshift + $secshift;
    my $cbytes = 1 << $cbshift;
    my $salign = $opt{align} ? $csize : 1;
    my $balign = $salign << $secshift;

    my $c = count_clusters($root, $cshift);
    my $fattype;
    my $nfats = $opt{strict} ? 2 : 1;

    # Partition table alignment quantum
    my $partalign = max($salign, $opt{strict} ? 64 : 1);

    # Reserved space; if the "extra files" part is set make sure there is at
    # least one free cluster per file, and enough space to put any
    # reserved files in subdirectories.
    #
    # Syntax: --reserve=<files>,<bytes>,<rootfiles>,<namelen>
    my @res = $opt{reserve} ? @{$opt{reserve}} : ();
    $res[0] = max($res[0], $res[2]);
    my $dirbytesperfile = (1 + div_up($res[3] || 64, 13)) << 5;
    $c += $res[0] + div_up($res[1], $cbytes);
    $c += div_up($dirbytesperfile * $res[0], $cbytes);

    # Subtract the cluster count for the root directory for the moment;
    # add them back later after FAT-type-specific modifications.
    my $rootclusts = div_up($root->{size}, $cbytes);
    $c -= $rootclusts;

    my $sectors = $c << $cshift;

    # FAT type == bits per entry
    if ($c < 0xff5) {
	$fattype = 12;
    } elsif ($c < 0xfff5) {
	$fattype = 16;
    } elsif ($c < 0x0ffffff5) {
	$fattype = 32;
	$c += $rootclusts;	# Root directory is a cluster chain
	if ($opt{strict}) {
	    return undef if ($cshift < 3 || $sectors < 0x1000000);
	}
    } else {
	return undef;		# Would require exFAT
    }

    # Size of each FAT
    my $fatsize = div_up(($c+2)*$fattype, 8);		 # Bytes
    $fatsize = align_up($fatsize, $balign) >> $secshift; # Sectors
    $sectors += $nfats*$fatsize;

    # Reserved sectors (in the FAT sense)
    my $resv = align_up(($fattype < 32) ? 1 : $opt{strict} ? 8 : 32, $salign);
    $sectors += $resv;

    # The root directory, if not FAT32
    my $rootdirsize;
    if ($fattype < 32) {
	$rootdirsize = $root->{size} + $res[2] * $dirbytesperfile;
	if ($opt{strict}) {
	    $rootdirsize = max($rootdirsize, ($fattype < 16 ? 256 : 512) << 5);
	}
	$rootdirsize = align_up($rootdirsize, $balign);
	$sectors += $rootdirsize >> $secshift;
    }

    # CHS geometry, in case someone actually that still cares...
    my $chs = [0, $opt{h} || 255, $opt{s} || 63];
    $chs->[0] = div_up($sectors+($opt{part} == $FLAT ? 0 : $partalign),
		       $chs->[1]*$chs->[2]);

    # Suitable MBR type
    my $mbrtype;
    if ($opt{efi}) {
	$mbrtype = 0xef;	# For MBR only, not PMBR
    } elsif ($fattype == 12) {
	$mbrtype = 0x01;
    } elsif ($fattype == 16) {
	$mbrtype =
	    $sectors < 0x10000 ? 0x04 : $chs->[0] <= 1024 ? 0x06 : 0x0e;
    } else {
	$mbrtype = 0x0c;
    }

    my $media = 0xf8;
    $media = 0xf0 if ($opt{part} == $FLAT && $chs->[0] <= 256);

    # Generated filesystem image parameters. May be an overestimate.
    return {
	'root' => $root, 'rootdirsize' => $rootdirsize,
	'sectors' => $sectors, 'cshift' => $cshift,
	'csectors' => 1 << $cshift, 'cbytes' => $cbytes,
	'cbshift' => $cbshift, 'fattype' => $fattype,
	'resv' => $resv, 'nfats' => $nfats, 'fatsize' => $fatsize,
	'clust' => $c, 'secshift' => $secshift, 'sector' => $sector,
	'mbrtype' => $mbrtype, 'gpttype' => $gpt_types[!!$opt{efi}],
	'partalign' => $partalign, 'chs' => $chs, 'media' => $media
    };
}

# Update the format parameters after the disk layout is complete
sub finalize_format_params($$$) {
    my($root, $startsec, $fssec) = @_;
    my $parm = $root->{parm};
    $parm->{hidden}  = $startsec;

    my $prefixsec = $parm->{resv} + $parm->{fatsize} * $parm->{nfats};
    $prefixsec += $parm->{rootdirsize} >> $parm->{secshift};

    # Offset to the data area in *sectors*
    $parm->{dataoffset} = ($startsec + $prefixsec) << $parm->{secshift};

    # Compute the final size of the filesystem
    my $fattypemax = (1 << $parm->{fattype}) - 12;
    my $fatsizemax = ($parm->{fatsize} << ($parm->{secshift} + 3))
	/ $parm->{fattype};
    my $spacemax = ($fssec - $prefixsec) >> $parm->{cshift};

    $parm->{clust}   = min($spacemax, $fattypemax, $fatsizemax);
    $parm->{sectors} = $prefixsec + ($parm->{clust} << $parm->{cshift});
}

# This walks the *subnodes* of a node of a certain type
sub populate_with($$$$) {
    my($dir, $parm, $type, $what) = @_;
    my $ret = 0;

    foreach my $de (@{$dir->{filelist}}) {
	if ($de->{type} == $type) {
	    $ret += $what->($de, $parm);
	}
	if ($de->{type} == $DIR) {
	    $ret += populate_with($de, $parm, $type, $what);
	}
    }
    return $ret;
}

# Assign cluster number to one file node
sub assign_clust($) {
    my($f) = @_;
    my $root = $f->{root};
    my $parm = $root->{parm};

    if (!defined($f->{size}) && defined($f->{data})) {
	$f->{size} = length($f->{data});
    }

    $f->{paddedsize} = align_up($f->{size}, $parm->{cbytes});
    $f->{nclust} = $f->{paddedsize} >> $parm->{cbshift};
    if (!$f->{nclust}) {
	$f->{clustno} = 0;
    } else {
	my $clustno = $f->{clustno} = $parm->{endclust};
	$parm->{endclust} += $f->{nclust};
	push(@{$root->{layout}}, $f);
	if ($opt{verbose} >= 3) {
	    printf STDERR "%s: cluster %5d @ 0x%08x (len %5d) for \"%s\"\n",
		$opt{outfile}, $clustno,
		$parm->{dataoffset} + (($clustno-2) << $parm->{cbshift}),
		$f->{nclust}, $f->{path} || '/';
	}
    }
    return $f->{nclust};
}

# Assign final cluster numbers and padded sizes to files and directories
sub assign_clusters($) {
    my($root) = @_;
    my $parm = $root->{parm};

    $parm->{endclust} = 2;	# First real cluster
    $root->{layout} = [];	# File nodes in layout order

    if ($parm->{rootdirsize}) {
	# FAT12/16: root directory is special
	$root->{clustno} = 0;
	$root->{paddedsize} = $parm->{rootdirsize};
	push(@{$root->{layout}}, $root);
	if ($opt{verbose} >= 3) {
	    printf STDERR "%s: root directory @ 0x%08x, %d sectors\n",
		$opt{outfile}, $parm->{dataoffset} - $root->{paddedsize},
		$root->{paddedsize} >> $parm->{secshift};
	}
    } else {
	assign_clust($root);
    }
    populate_with($root, $parm, $DIR,  \&assign_clust);
    populate_with($root, $parm, $FILE, \&assign_clust);
    die if ($parm->{endclust} > $parm->{clust} + 2);
}

# Emit one FAT entry. $hold should be a reference to a scalar
# used for the even-numbered (first) part of a FAT12 pair.
# The number should be masked so that the special numbers at the end
# of the number range can be represeented by -9 to -1.
sub emit_fat12($$$) {
    my($out, $num, $hold) = @_;

    $num &= 0xfff;

    if (!defined($$hold)) {
	$$hold = $num;
	return 0;
    }

    $num <<= 12;
    $num |= $$hold;
    undef($$hold);
    print $out pack('vC', $num & 0xffff, $num >> 16);
    return 3;
}
sub emit_fat16($$$) {
    my($out, $num, $hold) = @_;
    print $out pack('v', $num & 0xffff);
    return 2;
}
sub emit_fat32($$$) {
    my($out, $num, $hold) = @_;
    print $out pack('V', $num & 0x0fffffff);
    return 4;
}

sub emit_one_fat($) {
    my($root) = @_;
    my $parm = $root->{parm};
    my $out = $parm->{out};
    my %emit_func = (
	12 => \&emit_fat12,
	16 => \&emit_fat16,
	32 => \&emit_fat32
    );
    my $emit = $emit_func{$parm->{fattype}};
    my $hold;
    my $bytes = 0;

    # The two special entries at the start
    $bytes += $emit->($out, $parm->{media} - 256, \$hold);
    $bytes += $emit->($out, -1, \$hold);

    my $clustno = 2;
    foreach my $f (@{$root->{layout}}) {
	next if (!$f->{clustno});		# No cluster chain
	die if ($f->{clustno} != $clustno);	# This would be bad...
	my $nclust = $f->{nclust};
	while (--$nclust) {
	    # Emit the *next* cluster number
	    $bytes += $emit->($out, ++$clustno, \$hold);
	}
	$bytes += $emit->($out, -1, \$hold); # End of cluster chain
	$clustno++;
    }

    # Flush any partial output
    while (defined($hold)) {
	$bytes += $emit->($out, 0, \$hold);
    }

    $bytes += emitzero($out, ($parm->{fatsize} << 9) - $bytes);
    return $bytes;
}

# Maximum chunk size for writezero() and emit_file()
my $BUFSIZ = 1024*1024;

sub emit($@) {
    my $fh = shift(@_);
    my $bytes = 0;

    foreach my $s (@_) {
	$bytes += length($s);
	print $fh $s;
    }
    return $bytes;
}

sub emitzero($$) {
    my($fh, $bytes) = @_;
    my $left = $bytes;

    return 0 if ($left <= 0);

    while ($left) {
	my $chunk = min($left, $BUFSIZ);
	print $fh ("\0" x $chunk);
	$left -= $chunk;
    }
    return $bytes;
}

sub dosdate($) {
    my($time) = @_;
    my @lt = $opt{utc} ? gmtime($time) : localtime($time);

    $lt[5] -= 80;		# Convert year to 1980-based
    $lt[4] += 1;		# Convert month to 1-based
    if ($lt[5] < 0) {
	@lt = (0, 0, 0, 1, 1, 0);
    } elsif ($lt[5] > 127) {
	@lt = (59, 59, 23, 31, 12, 127);
    }

    return ($lt[5] << 25) + ($lt[4] << 21) + ($lt[3] << 16) +
	($lt[2] << 11) + ($lt[1] << 5) + ($lt[0] >> 1);
}

sub dir_shortent($$$$$) {
    my($name, $attr, $date, $clustno, $size) = @_;

    $size = 0 if ($attr & ($DIR|$VOL));

    my $datetime = $opt{date} || dosdate($date);
    return pack('A11Ca8vVvV', $name, $attr, '',
		$clustno >> 16, $datetime, $clustno & 0xffff, $size);
}

sub dir_longent($$) {
    my($longname, $shortent) = @_;

    my $namesum = 0;
    foreach my $nb (unpack('C11', $shortent)) {
	$namesum = (($namesum & 1) << 7) + ($namesum >> 1) + $nb;
	$namesum &= 0xff;
    }

    my $longpos = length($longname);
    my $longctr = ($longpos/26) | 0x40;
    my $longent = '';
    while ($longctr) {
	$longpos -= 26;
	$longent .= pack('Ca10CCCa12va4', $longctr,
			 substr($longname, $longpos, 10),
			 0x0f, 0, $namesum,
			 substr($longname, $longpos+10, 12),
			 0,
			 substr($longname, $longpos+22, 4));
	$longctr = ($longctr & 0x3f) - 1;
    }

    return $longent . $shortent;
}

sub emit_direntry($$) {
    my($f, $parm) = @_;

    my $attr = ($f->{type} & ($DIR|$VOL)) | $f->{flags};
    my $ent = dir_shortent($f->{shortname}, $attr, node_date($f),
			   $f->{clustno}, $f->{size});
    $ent = dir_longent($f->{longname}, $ent);

    return emit($parm->{out}, $ent);
}

# Emit the contents of a directory
sub emit_dir {
    my($dir, $parm) = @_;
    my $de;

    my $up = $dir->{up};
    my $bytes = 0;

    # Special entries at the beginning
    if (defined($up)) {
	# Not the root directory, emit . and ..
	my $dirdate = $dir->{date} = node_date($dir);

	$de  = dir_shortent('.',  $DIR, $dirdate, $dir->{clustno}, 0);

	# For some stupid reasons .. is supposed to have 0 in the cluster
	# pointer when it points to the root directory even on FAT32...
	my $upptr = defined($up->{up}) ? $up->{clustno} : 0;
	$de .= dir_shortent('..', $DIR, $dirdate, $upptr,  0);
	$bytes = emit($parm->{out}, $de);
    }

    # The regular directory entry list, already sorted
    foreach my $f (@{$dir->{filelist}}) {
	$bytes += emit_direntry($f, $parm);
    }

    die if ($bytes != $dir->{size});
    $bytes += emitzero($parm->{out}, $dir->{paddedsize} - $bytes);
    return $bytes;
}

# Copy the contents of a file
sub emit_file {
    my($f, $parm) = @_;
    my $bytes = 0;

    return if (!$f->{size});	# Empty file

    my $out = $parm->{out};

    if ($f->{populate}) {
	$bytes = $f->{populate}->($f, $parm, $out);
    } elsif (defined($f->{data})) {
	$bytes = emit($out, $f->{data});
    } elsif (defined($f->{inpath})) {
	my $sizeleft = $f->{size};
	my $in;
	if (open($in, '<', $f->{inpath})) {
	    binmode($in);
	    while ($sizeleft) {
		my $buf;
		my $chunk = read($in, $buf, min($BUFSIZ, $sizeleft));
		last if (!$chunk);
		$bytes += emit($out, $buf);
		$sizeleft -= $chunk;
	    }
	    close($in);
	}
	if ($sizeleft) {
	    print STDERR "%s: %s: %s\n", $opt{outfile}, $f->{inpath}, $!;
	    $err++;
	}
    }

    if ($bytes > $f->{size}) {
	print STDERR "%s: %s: output size overflow\n",
	    $opt{outfile}, $opt{path};
	$err++;
    }
    $bytes += emitzero($out, $f->{paddedsize} - $bytes);
    return $bytes;
}

# Generate the FAT superblock
sub emit_superblock($$) {
    my($root, $parm) = @_;
    my $fat = $parm->{fattype};

    my $sec32 = $parm->{sectors};
    my $sec16 = ($fat < 32 && $sec32 <= 0xffff) ? $sec32 : 0;

    $opt{creator} = 'WINNT4.1' if ($opt{winnt});

    my $bs = pack('CvA8vCvCvvCvvvVV',
		  0xe9, $KILLOFFS-3, $opt{creator},
		  $parm->{sector},
		  $parm->{csectors}, $parm->{resv}, $parm->{nfats},
		  $root->{clustno} ? 0 : $root->{paddedsize} >> 5,
		  $sec16, $parm->{media},
		  $fat < 32 ? $parm->{fatsize} : 0,
		  $parm->{chs}->[2], $parm->{chs}->[1],
		  $parm->{hidden}, $sec32);
    my $backupsb = 6;

    if ($fat >= 32) {
	# Weirdly injected in the middle of the FAT12/16 boot sector
	$bs .= pack('VvvVvva12', $parm->{fatsize}, 0, 0x0000,
		    $root->{clustno}, 1, $backupsb, '');
    }

    $bs .= pack('CCCa4A11A8.a*.v', 0x80, 0, 0x29, $root->{volid},
		$root->{vollbl}->{shortname}, "FAT$fat",
		$KILLOFFS - length($bs), $KILLBOOT,
		510 - length($bs), 0xaa55);

    my $out = $parm->{out};
    my $bytes = emit($out, $bs);

    if ($fat >= 32) {
	my $fsinfo = pack('A4a480A4VVa12V',
			  'RRaA', '', 'rrAa',
			  $parm->{clust} - $parm->{endclust} + 2,
			  $parm->{endclust},
			  '', 0xaa550000);
	$bytes += emit($out, $fsinfo);
	$bytes += emitzero($out, ($backupsb - 2) << 9);
	$bytes += emit($out, $bs, $fsinfo);
    }
    $bytes += emitzero($out, ($parm->{resv} << $parm->{secshift}) - $bytes);
    return $bytes;
}

# Create long and short volume labels.
sub create_vol_label($) {
    my($root) = @_;

    $root->{diskid} = parse_guid($opt{diskid});
    $root->{partid} = parse_guid($opt{partid});

    my @vo = hexgroups($opt{volid},4,4);
    $root->{volid} = @vo ? pack('vv',$vo[1],$vo[0]) : rand_bytes(4);

    my $vol = $opt{volname};
    $vol = 'EFI BOOT' if ($vol eq '' && $opt{efi});
    $vol = decode_utf8($vol);
    # The shortname is only used in the boot sector when no actual label
    $root->{vollbl} = {	'name' => $vol, 'up' => $root,
			'root' => $root, 'shortname' => 'NO NAME' };
    if ($vol ne '') {
	set_node_type($root->{files}->{' :vol'} = $root->{vollbl}, $VOL);
    }

    if ($opt{verbose} >= 1) {
	my $vostr = sprintf('%04X-%04X',reverse unpack('v*', $root->{volid}));
	print STDERR "$opt{outfile}: diskid ", guid_str($root->{diskid}) ,"\n";
	print STDERR "$opt{outfile}: partid ", guid_str($root->{partid}), "\n";
	printf STDERR "%s: volid  %s\n", $opt{outfile}, $vostr;
	printf STDERR "%s: label  %s\n", $opt{outfile},
	    $vol eq '' ? 'none' : "\"$vol\"";
    }
}

sub make_filesystem($) {
    my($root) = @_;

    create_vol_label($root);
    prep_directories($root);

    # Compute a suitable cluster shift.
    my $parm = undef;
    for (my $cs = 0; $cs < 7; $cs++) {
	my $thisparm = get_format_params($root, $cs);
	next unless (defined($thisparm));
	if ($opt{verbose} >= 3) {
	    printf STDERR "trial: clust %3d: FAT%d, sectors %8d, clusters %8d\n",
		1 << $cs, $thisparm->{fattype}, $thisparm->{sectors},
		$thisparm->{clust};
	}
	if (!defined($parm) || ($thisparm->{sectors} < $parm->{sectors})) {
	    $parm = $thisparm;
	}
	# Avoid 128-sector clusters unless we really need them
	last if (defined($parm) && $cs >= 6);
    }

    die "$opt{outfile}: filesystem too large\n" unless (defined($parm));
    $root->{parm} = $parm;

    # Cluster bytes
    my $csectors = $parm->{csectors};

    # Block alignment in sectors
    my $align     = $parm->{partalign};
    my $gptsize   = div_up(max($opt{gptent}, $opt{strict} ? 128 : 1),
			   $parm->{sector} >> 7);
    my $startsec  = 0;
    my $endsec    = 0;
    my $sectors   = $parm->{sectors};
    if ($opt{part} == $ANYPART) {
	$opt{part} = $opt{efi} || ($sectors+$align) > 0xffffffff ? $GPT : $MBR;
    }
    if ($opt{part} == $GPT) {
	$startsec   = $gptsize + 2; # +2 for PMBR, header
	if ($opt{backup_gpt}) {
	    $endsec   = $gptsize + 1;
	    $opt{pad} = 1;	# Padding to end of "disk" required
	}
    } elsif ($opt{part} == $MBR) {
	$startsec = 1;
    }
    # Initial partition table + alignment + space for backup gpt if necessary
    $startsec  = align_up($startsec, $align);
    $sectors   = align_up($sectors + $startsec + $endsec, $align);
    $endsec    = $sectors - $endsec;
    my $fssec  = $endsec  - $startsec;
    my $start  = $startsec << $parm->{secshift};

    # Update with the actually generated layout
    finalize_format_params($root, $startsec, $fssec);
    if ($opt{verbose} >= 2) {
	printf STDERR "%s: FAT%d, %d sectors, %d clusters * %d bytes\n".
	    "%s: filesystem @ 0x%08x, data @ 0x%08x\n",
	    $opt{outfile}, $parm->{fattype}, $fssec, $parm->{clust},
	    $parm->{cbytes},
	    $opt{outfile}, $start, $parm->{dataoffset};
    }
    assign_clusters($root);
    if ($opt{verbose} >= 1) {
	printf STDERR "%s: %d/%d clusters free\n",
	    $opt{outfile}, $parm->{clust} - ($parm->{endclust}-2),
	    $parm->{clust};
    }

    print $start, "\n" if ($opt{print_offset});

    # Output the image
    my $out;
    if ($opt{outfile} eq '-') {
	open($out, '&>', \*STDOUT);
    } else {
	open($out, '>', $opt{outfile});
    }
    die "$opt{outfile}: $!\n" unless (defined($out));
    binmode($out);
    $parm->{out} = $out;

    # Create the partition table
    my @part; # MBR, GPT header, GPT array, backup GPT header
    if ($opt{part} == $GPT) {
	@part = gen_gpt($sectors, $startsec, $fssec, $parm->{gpttype},
			$gptsize, $root->{vollbl}->{name},
			$root->{diskid}, $root->{partid}, $parm->{chs});
    } elsif ($opt{part} == $MBR) {
	$part[0] = gen_mbr($startsec, $fssec, $parm->{mbrtype},
			   $parm->{chs}, $parm->{active}, $root->{diskid});
    }

    my $bytes = emit($out, @part[0 ... 2]);
    $bytes += emitzero($out, $start - $bytes);
    die unless ($bytes == $start);

    # The boot sector/superblock
    $bytes += emit_superblock($root, $parm);

    # The FATs
    for (my $i = 0; $i < $parm->{nfats}; $i++) {
	$bytes += emit_one_fat($root);
    }

    # Root directory, subdirectories, files
    $bytes += emit_dir($root, $parm);
    $bytes += populate_with($root, $parm, $DIR,  \&emit_dir);
    $bytes += populate_with($root, $parm, $FILE, \&emit_file);

    # Finally, pad the image and output the backup GPT if there is one
    if ($opt{pad}) {
	$bytes += emitzero($out, ($endsec << $parm->{secshift}) - $bytes);
	$bytes += emit($out, @part[2 ... 3]) if (defined($part[3]));
	die unless ($bytes == ($sectors << $parm->{secshift}));
    }
    close($out);
}

sub usage(;$) {
    my($err) = @_;
    open(STDOUT, '>&', \*STDERR) if ($err);
    print <<EOF;
$myname $myversion
Usage: $0 [options] [-o] outfile [[[destination]:]:]input_path...

Create and populate a FAT filesystem image. By default it tries to
minimize the image as much as possible, leaving no free space and
minimizing all data structures to the smallest possible.

Inputs can be files or directories. :: alone as an input_path prefix
indicates that the entire input_path should be used as the destination
name, not just its contents (for a directory) or terminal filename
(for a file.)

A single : alone as an input_path prefix is exactly equivalent to no
prefix at all; this can be used as an escape in case input_path itself
may contain a double colon.

Options:
-o, --output             Specify the output file (- for standard output)
    --flat, --no-part    Do not create a partition table
    --part               Create a partion table, either MBR or GPT [default]
    --mbr                Create an MBR partition table
    --gpt[=<partitions>] Create a GPT partition table [default with --efi]
-e ,--efi, --uefi        Mark the partition as an EFI system partition
-b, --boot, --active     Mark the partition as legacy BIOS bootable
-L, --label=<name>	 Set the filesystem volume name
-H, --heads=#            Define heads per cylinder for legacy geometry [255]
-S, --secpertrack=#      Define sectors per track legacy geometry [63]
-v, --verbose[=#]        Set message verbosity
-r, --reserve=<files>,<bytes>,<rootfiles>,<namelen>
                         Specify additional space to reserve in the filesystem
             files:      Specify the minimum number of (small) new files [0]
             bytes:      Specify additional bytes of free space [0]
             rootfiles:  Indicate how may of <files> may be in / [0]
             namelen:    Assumed maximum filename length for new files [64]
-m, --media              Settings suitable for writing to physical media
-s, --strict             Strictly adhere to recommended filesystem parameters
			 (enhances compatibility but generates larger images)
-a, --align              Align data structures to multiples of the cluster size
    --no-pad             Do not write out empty sectors at the end of the image
    --no-backup-gpt      Omit the end-of-image backup GPT partition table
    --volid=<id>         Set the volume ID to <id> (8 hex digits)
    --partid=<id>        Set the partition ID to <id> (GUID, GPT only)
    --diskid=<id>        Set the disk ID to <id> (GUID for GPT, 8 hex for MBR)
-U, --utc                Create time stamps in UTC, not local time
-D, --date=<date>        Force the time stamp of all files to <date>
-C, --creator=<name>     Set the filesystem creator name to <name> [FatImage]
    --print-offset       Print filesystem offset in the image after completion
-V, --version            Display the version information
-h, --help               Display this help text
EOF
    exit($err);
}
sub get_arg($$;$) {
    my($args,$os,$truth) = @_;

    return undef if (defined($truth) && !$truth);
    return $1 if ($os =~ /^-.*?=(.*)$/);	# = separated argument
    return undef if ($truth < 0);		# Missing optional argument
    my $arg = shift(@$args);
    die "$0: option -$os requires an argument\n" if (!defined($arg));
    return $arg;
}
sub get_arg_uints($$;$$) {
    my($args,$os,$truth,$cmax) = @_;

    my $arg = get_arg($args, $os, $truth);
    return () unless ($arg ne '');

    my @ns;
    foreach my $a (split(/,/, $arg)) {
	if ($a =~ /^\s*(0x[0-9a-f]|[0-9]+)\s*([kmgtpe])?\s*$/i) {
	    my $suf = lc($2);
	    my $n = $1;
	    $n = hex($n) if ($n =~ /^0x/i);
	    push(@ns, $n << (10 * index(' kmgtpe', $suf)));
	} else {
	    undef @ns;
	    last;
	}
    }
    if (!@ns || scalar(@ns) > max($cmax,1)) {
	die "$0: invalid argument to -$os: $arg\n";
    }
    return \@ns;
}
sub get_arg_uint($$;$) {
    my($args,$os,$truth) = @_;
    my $ns = get_arg_uints($args, $os, $truth);
    return $ns ? $ns->[0] : undef;
}

sub do_options($@) {
    my $args = shift(@_);	# Argument list pointer

    foreach my $optn (@_) {
	my $os = $optn;
	my $truth = ($os !~ s/^-no-?([^=]+)$/-$1/);

	if ($os =~ /^(?:o|-output)$/) {
	    $opt{output} = $truth ? get_arg($args, $os) : File::Spec->devnull();
	} elsif ($os =~ /^(?:e|-efi|-uefi)$/) {
	    $opt{efi} = $truth;
	} elsif ($os =~ /^(?:g|-gpt)(=(\d+))$/) {
	    if ($truth) {
		$opt{part} = $GPT;
		$opt{gptent} = $2+0 if ($1);
	    } else {
		$opt{part} = $FLAT unless ($opt{part} == $MBR);
	    }
	} elsif ($os =~ /^(?:b|-active|-(?:legacy-?)?boot(?:able)?)$/) {
	    $opt{active} = $truth;
	} elsif ($os =~ /^(?:m|-mbr)$/) {
	    if ($truth) {
		$opt{part} = $MBR;
	    } else {
		$opt{part} = $FLAT unless ($opt{part} == $GPT);
	    }
	} elsif ($os =~ /^(?:f|-flat)$/) {
	    if ($truth) {
		$opt{part} = $FLAT;
	    } else {
		$opt{part} = $ANYPART if ($opt{part} == $FLAT);
	    }
	} elsif ($os =~ /^(?:p|-part)$/) {
	    if ($truth) {
		$opt{part} = $ANYPART unless ($opt{part} > $FLAT);
	    } else {
		$opt{part} = $FLAT;
	    }
	} elsif ($os =~ /^(?:r|-reserve)(?:=.*)?$/) {
	    $opt{reserve} = get_arg_uints($args,$os,$truth,4);
	} elsif ($os =~ /^(?:v|-verbose)(=(\d+))?$/) {
	    $opt{verbose} = !$truth ? 0 : $1 ? $2+0 : $opt{verbose}+1;
	} elsif ($os =~ /^(?:q|-quiet)$/) {
	    $opt{verbose} = $truth ? 0 : max($opt{verbose}, 1);
	} elsif ($os =~ /^(?:H|-heads)(?:=.*)?$/) {
	    $opt{h} = get_arg_uint($args, $os,$truth);
	} elsif ($os =~ /^(?:S|-secpertrack)(?:=.*)?$/) {
	    $opt{s} = get_arg_uint($args, $os,$truth);
	} elsif ($os =~ /^(?:L|n|-label|-name|-volume(?:-?name)?)(?:=.*)?$/) {
	    $opt{volname} = get_arg($args,$os,$truth) . '';
	} elsif ($os =~ /^(?:s|-strict)$/) {
	    $opt{strict} = $truth;
	} elsif ($os =~ /^(?:a|-align)$/) {
	    $opt{align} = $truth;
	} elsif ($os eq '-pad') {
	    $opt{pad} = $truth;
	} elsif ($os =~ /^(?:m|-media)$/) {
	    $opt{media} = $truth;
	} elsif ($os =~ /^-diskid(?:=.*)?$/) {
	    $opt{diskid} = get_arg($args,$os,$truth);
	} elsif ($os =~ /^-partid(?:=.*)?$/) {
	    $opt{partid} = get_arg($args,$os,$truth);
	} elsif ($os =~ /^-volid(?:=.*)?$/) {
	    $opt{volid} = get_arg($args,$os,$truth);
	} elsif ($os =~ /^(?:C|-creator)(?:=.*)?$/) {
	    $opt{creator} = get_arg($args,$os,$truth);
	} elsif ($os =~ /^(?:D|-date(?:time)?)(?:=.*)?$/) {
	    $opt{date} = get_arg($args,$os,$truth);
	} elsif ($os =~ /^(?:U|-utc|-gmt)$/) {
	    $opt{utc} = $truth;
	} elsif ($os =~ /^-print-offset$/) {
	    $opt{print_offset} = $truth;
	} elsif ($os =~ /^(?:h|-help)$/) {
	    usage(0);
	} elsif ($os =~ /^(?:V|-version)$/) {
	    print "$myname $myversion\n";
	    exit(0);
	} else {
	    die "$0: unknown option: -$os (--help for help)\n";
	}
    }
}

sub parse_options(@_) {
    my(@args) = @_;
    my $output;

    while (defined(my $arg = $args[0])) {
	last if ($arg !~ /^-((-?).*)$/);
	shift(@args);
	if ($2) {
	    last if ($1 eq '-');
	    do_options(\@args, $1);
	} else {
	    do_options(\@args, split(//, $1));
	}
    }
    $opt{outfile} = shift(@args) unless (defined($opt{outfile}));

    return @args;		# Input files
}

sub mystr2date($$) {
    my($date, $utc) = @_;
    my $tz = $utc ? '+0000' : undef;
    if ($date =~ /^\@?0?x([0-9a-f]+)$/i) {
	$date = hex $date;
    } elsif ($date =~ /^\@?\d+$/) {
	$date += 0;
    } elsif (!defined($date = str2date($date, $tz))) {
	die "$0: invalid date: $date\n";
    }
    return $date;
}

my(@inputs) = parse_options(@ARGV);
if (!@inputs) {
    die "$0: no input files (see --help for usage)\n";
}

# Hopefully correct...?!
binmode(STDERR, ':encoding(UTF-8)');

# Postprocessing of some options
unless (defined($opt{creator})) {
    $opt{creator} = $opt{strict} ? 'WINNT4.1' : 'FatImage';
}
if ($opt{media}) {
    $opt{strict} = 1 unless (defined($opt{strict})); # AFTER setting {creator}
    $opt{align}  = 1 unless (defined($opt{align}));
}
$opt{date} = dosdate(mystr2time($opt{date}, $opt{utc})) if ($opt{date} ne '');

my $root = read_inputs(@inputs);
exit(1) if ($err);

make_filesystem($root);
exit(0);
